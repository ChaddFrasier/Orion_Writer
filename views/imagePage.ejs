<html>
    <head>
        <!-- Required meta tags -->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=yes">

        <link rel="stylesheet", href="css/pips.css" type="text/css">

        <!-- Bootstrap CSS -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
            integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

        <title>Image Editor</title>

        <script src="http://ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js"></script>
    </head>
<!--  FOR TESTING WILL MOVE TO CSS FILE LATER -->
    <style>
        input.largeBox{
            left: 13rem;
            top: 16.5rem;
            transform: scale(1.75); 
        }
        .draw:hover{
            cursor: url("images/pencilcursor.png"),auto;
        }
        .textbox{
            font: bold Courier serif;
            visibility: visible;
            letter-spacing: 3px
        }
    </style>
<!--============================================= -->
<script>
    // function to create a draggable field from svg element
    function makeDraggable(event) {
    
        // get svg element
        var svg = event;
    
        // adds event functions to the whole svg element
        svg.addEventListener('mousedown', startDrag);
        svg.addEventListener('mousemove', drag);
        svg.addEventListener('mouseup', endDrag);
        svg.addEventListener('mouseleave', endDrag);
        
        // decrale all global function variables for dragging
        var selectedElement, offset, transform,
            bbox, minX, maxX, minY, maxY, confined;
        // & for resizing
        var resizing = false,
            dragging = false,
            currentScale,
            transformString,
            startH,
            startW,
            minNorth = .1219513,
            maxNorth = 1.219513,
            minSun = .15625,
            maxSun = 1.5625,
            minEye = .15625,
            maxEye = 1.5625,
            iconMin,
            outlineMin = .125,
            scale;
        
            
        // sets boundries for draggable objects when confined based on the view box
        // minX = x of viewbox
        var boundaryX1 = Number(svg.getAttribute('viewBox').split(" ")[0]);
        // maxX = the width of the viewbox - the absolute value of the x value
        var boundaryX2 = Number(svg.getAttribute('viewBox').split(" ")[2]) - Math.abs(Number(svg.getAttribute('viewBox').split(" ")[0]));
        // minY = y of the viewBox
        var boundaryY1 = Number(svg.getAttribute('viewBox').split(" ")[1]);
        // maxY = the height of the viewbox - the absolute value of the  y of the view box
        var boundaryY2 = Number(svg.getAttribute('viewBox').split(" ")[3]) - Math.abs(Number(svg.getAttribute('viewBox').split(" ")[1]));


        


        // get the mouse position relative to the svg screen matrix
        // math functions were found on a blog post
        function getMousePosition(event) {
            var CTM = svg.getScreenCTM();
            
            return {
                x: (event.clientX - CTM.e) / CTM.a,
                y: (event.clientY - CTM.f) / CTM.d
            };
        }

        // start the drag on mousedown
        function startDrag(event){
            // get the mouseX and mouseY on the client
            mX = event.clientX, mY = event.clientY;
            // prevent all other mousedown events
            event.preventDefault();
            // find what element the event is on
            var elementOver = document.elementFromPoint(mX,mY);
            // get the element that needs to be dragged or scaled
            selectedElement = event.target.parentNode;

            if(selectedElement === svg){
                selectedElement = event.target;
            }

            // grab the limits scale value for whichever icon is selected
            // functions find min if passed true and find max if passed false
            iconMin = findLimit(selectedElement,true);
            iconMax = findLimit(selectedElement, false);
            // get the bounding box of the group element
            bbox = selectedElement.getBBox();
            // Make sure the first transform on the element is a translate transform
            var transforms = selectedElement.transform.baseVal;


            // if the element that the mousedown happened over is a resize block and the function is not currently resizing,
            // start resize logic
            if(elementOver.classList.contains('resize') && !resizing){
                // set resizing flag
                resizing = true;
            
                 // get scale data
                scale = transforms.getItem(transforms.length -1);

                // get the coordinates where the click happend inside the svg box
                offset = getMousePosition(event);

                // get the transform string so we can change it later strip the scale part off the end because we are resizing
                transformString = selectedElement.getAttribute("transform").split("scale(")[0];
                
                // extract the scale value as a number
                currentScale = scale.matrix.a;

                
                
                // get translate data
                transform = transforms.getItem(0);

            }
            // if the event click happened on a draggable element start drag logic
            else if (selectedElement.classList.contains('draggable')) {
                // set dragging flag
                dragging = true;
                // get the offset value for the translation
                offset = getMousePosition(event);
                 // get scale data
                scale = transforms.getItem(transforms.length -1);

                // make sure that the first element of the tranform object is the translate and create one if it isnt there
                if (transforms.length === 0 || transforms.getItem(0).type !== SVGTransform.SVG_TRANSFORM_TRANSLATE) {
                // sets current transform position to 0,0 to make moving item easier
                var translate = svg.createSVGTransform();
                translate.setTranslate(0, 0);
                selectedElement.transform.baseVal.insertItemBefore(translate, 0);
                }

                // Get initial translation in relation to the current mouse position (offset) and the current translation
                transform = transforms.getItem(0);

                // calculate the transform location in relation to the svg element
                offset.x -= transform.matrix.e;
                offset.y -= transform.matrix.f;

                // is the selected item confined?
                confined = selectedElement.classList.contains('confine');

                // if true
                if (confined) {
                    let rotateVal = transforms.getItem(1).angle;
                    // if no rotate has occured
                    if(rotateVal ===0 || rotateVal === 360 ){
                        // get the current scale of the icon
                        let scaleFactor = scale.matrix.a;
                        bbox = selectedElement.getBBox();
                        // set the new boundry values based on the view box and the width/height of the icons
                        // dim * scale = dim of icon
                        minX = boundaryX1 - bbox.x;
                        maxX = boundaryX2 - bbox.x - bbox.width * scaleFactor;
                        minY = boundaryY1 - bbox.y;
                        maxY = boundaryY2 - bbox.y - bbox.height * scaleFactor;

                        console.log('BOUNDING DIMENSIONS ARE: ' + minX + ' ' + minY +' ' +maxX + ' ' + maxY  );
                    }
                    else{
                        // rotate has been applied
                        
                        console.log("ROTATE: " + rotateVal);
                        var trigInput = rotateVal * Math.PI/180;
                        var trigInput2 = (rotateVal-90) * Math.PI/180;
                        var trigInput3 = (rotateVal-180) * Math.PI/180;
                        var trigInput4 = (rotateVal-270) * Math.PI/180;

                        // BEST WAY SO FAR ============================================================================================
                        if(rotateVal === 180){
                            // get the current scale of the icon
                            let scaleFactor = scale.matrix.a;
                            bbox = selectedElement.getBBox();
                            // set the new boundry values based on the view box and the width/height of the icons
                            // dim * scale = dim of icon
                            minX = boundaryX1 - bbox.x+ bbox.width * scaleFactor;
                            maxX = boundaryX2 - bbox.x;
                            minY = boundaryY1 - bbox.y + bbox.height * scaleFactor;
                            maxY = boundaryY2 - bbox.y;

                            console.log('BOUNDING DIMENSIONS ARE: ' + minX + ' ' + minY +' ' +maxX + ' ' + maxY  );
                        }else if(rotateVal === 90){
                            // get the current scale of the icon
                            let scaleFactor = scale.matrix.a;
                            bbox = selectedElement.getBBox();
                            // set the new boundry values based on the view box and the width/height of the icons
                            // dim * scale = dim of icon
                            minX = boundaryX1 - bbox.x + bbox.height * scaleFactor;
                            maxX = boundaryX2 - bbox.x;
                            minY = boundaryY1 - bbox.y;
                            maxY = boundaryY2 - bbox.y - bbox.width * scaleFactor;

                            console.log('BOUNDING DIMENSIONS ARE: ' + minX + ' ' + minY +' ' +maxX + ' ' + maxY  );
                        }else if(rotateVal === 270){
                            // get the current scale of the icon
                            let scaleFactor = scale.matrix.a;
                            bbox = selectedElement.getBBox();
                            // set the new boundry values based on the view box and the width/height of the icons
                            // dim * scale = dim of icon
                            minX = boundaryX1 - bbox.x;
                            maxX = boundaryX2 - bbox.x - bbox.height * scaleFactor;
                            minY = boundaryY1 - bbox.y + bbox.width * scaleFactor;
                            maxY = boundaryY2 - bbox.y;

                            console.log('BOUNDING DIMENSIONS ARE: ' + minX + ' ' + minY +' ' +maxX + ' ' + maxY  );
                        }
                        else if(rotateVal === 45){
                            // get the current scale of the icon
                            let scaleFactor = scale.matrix.a;
                            bbox = selectedElement.getBBox();
                            // set the new boundry values based on the view box and the width/height of the icons
                            // dim * scale = dim of icon
                            minX = boundaryX1 - bbox.x + (bbox.height * scaleFactor/Math.sqrt(2));
                            maxX = boundaryX2 - bbox.x - (bbox.width * scaleFactor)/Math.sqrt(2);
                            minY = boundaryY1 - bbox.y;
                            maxY = boundaryY2 - bbox.y - (bbox.width * scaleFactor)/Math.sqrt(2) - (bbox.height * scaleFactor)/Math.sqrt(2);

                            console.log('BOUNDING DIMENSIONS ARE: ' + minX + ' ' + minY +' ' +maxX + ' ' + maxY  );
                        }
                        else if(rotateVal === 135){
                            // get the current scale of the icon
                            let scaleFactor = scale.matrix.a;
                            bbox = selectedElement.getBBox();
                            // set the new boundry values based on the view box and the width/height of the icons
                            // dim * scale = dim of icon
                            minX = boundaryX1 - bbox.x + (bbox.height * scaleFactor/Math.sqrt(2)+ (bbox.width * scaleFactor/Math.sqrt(2)));
                            maxX = boundaryX2 - bbox.x;
                            minY = boundaryY1 - bbox.y + (bbox.height * scaleFactor)/Math.sqrt(2);
                            maxY = boundaryY2 - bbox.y - (bbox.width * scaleFactor)/Math.sqrt(2);

                            console.log('BOUNDING DIMENSIONS ARE: ' + minX + ' ' + minY +' ' +maxX + ' ' + maxY  );
                        }
                        else if(rotateVal === 225){
                            // get the current scale of the icon
                            let scaleFactor = scale.matrix.a;
                            bbox = selectedElement.getBBox();
                            // set the new boundry values based on the view box and the width/height of the icons
                            // dim * scale = dim of icon
                            minX = boundaryX1 - bbox.x + (bbox.width * scaleFactor/Math.sqrt(2));
                            maxX = boundaryX2 - bbox.x - bbox.height * scaleFactor/Math.sqrt(2);
                            minY = boundaryY1 - bbox.y + (bbox.height * scaleFactor)/Math.sqrt(2) + (bbox.width * scaleFactor)/Math.sqrt(2);
                            maxY = boundaryY2 - bbox.y;

                            console.log('BOUNDING DIMENSIONS ARE: ' + minX + ' ' + minY +' ' +maxX + ' ' + maxY  );
                        }
                        else if(rotateVal === 315){
                            // get the current scale of the icon
                            let scaleFactor = scale.matrix.a;
                            bbox = selectedElement.getBBox();
                            // set the new boundry values based on the view box and the width/height of the icons
                            // dim * scale = dim of icon
                            minX = boundaryX1 - bbox.x;
                            maxX = boundaryX2 - bbox.x  - bbox.height * scaleFactor/Math.sqrt(2) - bbox.width * scaleFactor/Math.sqrt(2);
                            minY = boundaryY1 - bbox.y  + (bbox.width * scaleFactor)/Math.sqrt(2);
                            maxY = boundaryY2 - bbox.y - (bbox.height * scaleFactor)/Math.sqrt(2);

                            console.log('BOUNDING DIMENSIONS ARE: ' + minX + ' ' + minY +' ' +maxX + ' ' + maxY  );
                        }
                        else if(rotateVal < 90){
                            // get the current scale of the icon
                            let scaleFactor = scale.matrix.a;
                            bbox = selectedElement.getBBox();
                            // set the new boundry values based on the view box and the width/height of the icons
                            // dim * scale = dim of icon
                            minX = boundaryX1 - bbox.x  + Math.sin(trigInput)*(bbox.height*scaleFactor);
                            maxX = boundaryX2 - bbox.x - Math.cos(trigInput)*(bbox.width*scaleFactor);
                            minY = boundaryY1 - bbox.y;
                            maxY = boundaryY2 - bbox.y - (Math.cos(trigInput)*(bbox.height*scaleFactor) + Math.sin(trigInput)*(bbox.width*scaleFactor));

                            console.log('BOUNDING DIMENSIONS ARE HERE: ' + minX + ' ' + minY +' ' +maxX + ' ' + maxY  );
                        }
                        else if(rotateVal < 180){
                            // get the current scale of the icon
                            let scaleFactor = scale.matrix.a;
                            bbox = selectedElement.getBBox();
                            // set the new boundry values based on the view box and the width/height of the icons
                            // dim * scale = dim of icon
                            console.log(trigInput2);
                            minX = boundaryX1 - bbox.x + Math.sin(trigInput2) * (bbox.width*scaleFactor) + Math.cos(trigInput2)*(bbox.height*scaleFactor);;
                            maxX = boundaryX2 - bbox.x;
                            minY = boundaryY1 - bbox.y + Math.sin(trigInput2)*(bbox.height*scaleFactor);
                            maxY = boundaryY2 - bbox.y - (Math.cos(trigInput2)*(bbox.width*scaleFactor));

                            console.log('BOUNDING DIMENSIONS ARE HERE2: ' + minX + ' ' + minY +' ' +maxX + ' ' + maxY  );
                        }
                        else if(rotateVal < 270){
                            // get the current scale of the icon
                            let scaleFactor = scale.matrix.a;
                            bbox = selectedElement.getBBox();
                            // set the new boundry values based on the view box and the width/height of the icons
                            // dim * scale = dim of icon
                            
                            minX = boundaryX1 - bbox.x + Math.cos(trigInput3) * (bbox.width*scaleFactor);
                            maxX = boundaryX2 - bbox.x - Math.sin(trigInput3) * (bbox.height*scaleFactor);
                            minY = boundaryY1 - bbox.y + Math.cos(trigInput3)*(bbox.height*scaleFactor) + Math.sin(trigInput3)*(bbox.width*scaleFactor);
                            maxY = boundaryY2 - bbox.y;

                            console.log('BOUNDING DIMENSIONS ARE HERE2: ' + minX + ' ' + minY +' ' +maxX + ' ' + maxY  );
                        }
                        else if(rotateVal < 360){
                            // get the current scale of the icon
                            let scaleFactor = scale.matrix.a;
                            bbox = selectedElement.getBBox();
                            // set the new boundry values based on the view box and the width/height of the icons
                            // dim * scale = dim of icon
                            
                            minX = boundaryX1 - bbox.x;
                            maxX = boundaryX2 - bbox.x - Math.cos(trigInput4) * (bbox.height*scaleFactor) - Math.sin(trigInput4) * (bbox.width*scaleFactor);
                            minY = boundaryY1 - bbox.y + Math.cos(trigInput4)*(bbox.width*scaleFactor);
                            maxY = boundaryY2 - bbox.y - Math.sin(trigInput4)*(bbox.height*scaleFactor);

                            console.log('BOUNDING DIMENSIONS ARE HERE2: ' + minX + ' ' + minY +' ' +maxX + ' ' + maxY  );
                        }
                    }
                }
            }
        }

        // set flags for rescale
        var bottomL = false,
            bottomR = false,
            topR = false,
            topL = false;
        
        // move the icon when mouse moves or scale the icon when needed

        /* IMORTANT: 
            In order to scale the icon in a manner that looks and feels natural for the user
                I am calculating the staring width and height of the icon and shifting the translate by that much
                This gives the illusion that the  icon is growing from the side they are dragging from
            */
        function drag(event) {
            // get the mouse x and y based on client
            mX = event.clientX, mY = event.clientY;

            // set the factor at which the resize happens
            let growingFactor = .02;
            // get the element that the mouse is over
            var elementOver = document.elementFromPoint(mX,mY);

            if(selectedElement){
                var isOutline = selectedElement.classList.contains("outline");
            }
            
            // prevent all other mousemove events
            event.preventDefault();
            
            // if the selectedElement is not null and resizing is true and dragging is false
            if(selectedElement && resizing && !dragging){
         
                // get new mouse position in svg space
                var coord = getMousePosition(event);

                // calculate icon size using bbox height and width times the scale 
                startH = bbox.height * currentScale;
                startW = bbox.width * currentScale;

                
                // first make sure there are no other flags active and
                // either the top right element is moused over or the top right is being moved
                if((!topL && !bottomL && !bottomR) && (elementOver.classList.contains('top-right') || topR)){
                    //set the flag just incase it isn't
                    topR = true;
                    // if the new x is less  & the new y is greater than the old position then shrink
                    if(coord.x < offset.x && coord.y > offset.y){
                        // decrement by the growing factor
                        currentScale -= growingFactor;
                        // check for the min
                        if(currentScale < iconMin){currentScale = iconMin;}

                        // translate the icon 0 in the x direction and by the difference in the positive y direction
                        dx = parseInt(transform.matrix.e);
                        dy = parseInt(transform.matrix.f + Math.abs(startH - bbox.height * currentScale)/2);
                    }
                    // if the old x is greater and the new y is smaller then we are growing
                    else if(coord.x > offset.x && coord.y < offset.y){
                        // increment by the factor
                        currentScale += growingFactor;

                        // check for max size
                        if(currentScale > iconMax){currentScale = iconMax;}
                        if(!isOutline && bbox.height * currentScale > parseInt("<%=h%>")/3){currentScale -= growingFactor}
                        
                        // translate the icon 0 in the x direction and by the difference in the negative y direction        
                        dx = parseInt(transform.matrix.e);
                        dy = parseInt(transform.matrix.f - Math.abs(startH - bbox.height * currentScale)/2);

                       
                    }

                    // set scale using svg data method
                    scale.setScale(currentScale,currentScale);
                    // if parse it returns a true value for both
                    /* if(dx && dy){
                        // set the new translate
                        transform.setTranslate(dx,dy);
                    } */
                    // set the new mouse position as the old so we can scale up and down
                    offset = coord;
                }
                // using the same logic for other corners of the scale
                else if((!topR && !bottomL && !bottomR) && (elementOver.classList.contains('top-left') || topL)){
                    topL = true;
                    // if new x is greater than the old & the new y is greater than the old
                    // shrink the scale
                    if(coord.x > offset.x && coord.y > offset.y){
                        currentScale -= growingFactor;
                        // check for min
                        if(currentScale < iconMin){currentScale = iconMin;}

                        // transform the icon by the positive difference in the sizes                        
                        dx = parseInt(transform.matrix.e + Math.abs(startW - bbox.width * currentScale)/2);
                        dy = parseInt(transform.matrix.f + Math.abs(startH - bbox.height * currentScale)/2);
                    }
                    // if the new x and new y are both less than the old position
                    // grow
                    else if(coord.x < offset.x && coord.y < offset.y){
                        currentScale += growingFactor;


                        // check for max size
                        if(currentScale > iconMax){currentScale = iconMax;}
                        if(!isOutline && bbox.height * currentScale > parseInt("<%=h%>")/3){currentScale -= growingFactor}

                        // transform the icon by the negative difference in the sizes
                        dx = parseInt(transform.matrix.e - Math.abs(startW - bbox.width * currentScale)/2);
                        dy = parseInt(transform.matrix.f - Math.abs(startH - bbox.height * currentScale)/2);
                    }

                    // set scale using svg data method
                    scale.setScale(currentScale,currentScale);
                    // if parse it returns a true value for both
                    /* if(dx && dy){
                        // set the new translate
                        transform.setTranslate(dx,dy);
                    } */

                    // set new mouse position
                    offset = coord;
                }
                // same logic as other corners
                else if((!bottomR && !topR && !topL) && (elementOver.classList.contains('bottom-left') || bottomL)){
                    bottomL = true;
                    // if new x is greater and new y is less
                    // shrink
                    if(coord.x > offset.x && coord.y < offset.y){
                        currentScale -= growingFactor;
                        // check for min
                        if(currentScale < iconMin){currentScale =iconMin;}
                        

                        // transform the icon by the negative difference in the sizes keep y the same
                        dx = parseInt(transform.matrix.e + Math.abs(startW - bbox.width * currentScale)/2);
                        dy = parseInt(transform.matrix.f);


                    }
                    // of the new x is less and the new y is greater
                    // grow the icon
                    else if(coord.x < offset.x && coord.y > offset.y){
                        currentScale += growingFactor;

                        // check for max size
                        if(currentScale > iconMax){currentScale = iconMax;}
                        if(!isOutline && bbox.height * currentScale > parseInt("<%=h%>")/3){currentScale -= growingFactor}
                        
                        // transform the icon by the negative difference in the sizes keep y the same
                        dx = parseInt(transform.matrix.e - Math.abs(startW - bbox.width * currentScale)/2);
                        dy = parseInt(transform.matrix.f);

                    }
                    
                    // set scale using svg data method
                    scale.setScale(currentScale,currentScale);
                    // if parse it returns a true value for both
                    /* if(dx && dy){
                        // set the new translate
                        transform.setTranslate(dx,dy);
                    } */

                    // set new mouse position
                    offset = coord;
                }
                // same logic as other corners 
                else if((!topL && !topR && !bottomL) && (elementOver.classList.contains('bottom-right') || bottomR)){
                    bottomR = true;
                    // if the new x is less and the new y is also less
                    // shrink
                    if(coord.x < offset.x && coord.y < offset.y){
                        currentScale -= growingFactor;
                        // check min bound
                        if(currentScale < iconMin){currentScale = iconMin;}
                    }
                    // if the new x is greater than the old and the new y is greater
                    // grow
                    else if(coord.x > offset.x && coord.y > offset.y){
                        currentScale += growingFactor;

                        //check for max size
                        if(currentScale > iconMax){currentScale = iconMax;}
                        if(!isOutline && bbox.height * currentScale > parseInt("<%=h%>")/3){currentScale -= growingFactor}
                    }
                    // set scale using svg data method
                    scale.setScale(currentScale,currentScale);
                    // no need to translate for bottom right corner
                    // set new mouse position
                    offset = coord;
                }
                       
            }
            // if the selected element is not null and the dragging flag is true
            else if (selectedElement && dragging) {
             
                // get mouse coordinates
                var coord = getMousePosition(event);
                // calculate the difference in the two
                var dx = coord.x - offset.x;
                var dy = coord.y - offset.y;

                // if the icon is confined check for boundry values
                if (confined) {
                    if (dx < minX) { dx = minX; }
                    else if (dx > maxX) { dx = maxX; }
                    if (dy < minY) { dy = minY; }
                    else if (dy > maxY) { dy = maxY; }
                }
                // set the transform
                transform.setTranslate(dx, dy);
                
            }
        }

        // when mouseup or mouse leave the svg box reset all flags 
        // and set the selectedElement to null
        function endDrag(event) {
            
            if(selectedElement){
                drag(event);
                resizing = false;
                dragging = false;
                bottomL = false;
                bottomR = false;
                topL = false;
                topR = false;
            }
          selectedElement = null;
        }

        // given an icon element returnns the min scale value for each icon to test against the new scale
        function findLimit(selectedElement, isMin){
            if(isMin){
                if(selectedElement.id.indexOf('north') !== -1){
                    return minNorth;
                }
                else if(selectedElement.id.indexOf('sun') !== -1){
                    return minSun;
                }
                else if(selectedElement.id.indexOf('eye') !== -1){
                    return minEye;
                }
                else if(selectedElement.id.indexOf('attension') !== -1){
                    return outlineMin;
                }
            }
            else{
                if(selectedElement.id.indexOf('north') !== -1){
                    return maxNorth;
                }
                else if(selectedElement.id.indexOf('sun') !== -1){
                    return maxSun;
                }
                else if(selectedElement.id.indexOf('eye') !== -1){
                    return maxEye;
                }
            }
        }        
    }// end make dragable

</script>

    <body>
        <!-- Page Header Block-->
        <img src="../images/usgsLogo.png" class="float-md-left" width="10%" height="auto" style="margin: 0%; padding: 0%">
        <div class="container">
            <div class="jumbotron text-center" >
                <h2>Edit the Cube Image</h2>      
                </div>
            </div>
        </div>

        <!-- Loading GIF-->
        <div id="loading" class="float-md-right lead" style="visibility:visible">
            <img src="../images/loading.gif" class='float-center;' height="125px" weight="135px"/><br/>Loading
        </div>
        

<!-- Editor Box -->
<svg id="svgWrapper" xmlns="http://www.w3.org/2000/svg" version='1.1' stroke="black" fill="black"  xmlns:xlink="http://www.w3.org/1999/xlink" 
class="image-image float-center" viewBox="0 0 <%=w%> <%=h%>" style="fill:black;" width='<%=w%>' height='<%=h%>'> 
    <rect id="svgBackground" x="0" y="0" width="<%=w%>" height="<%=h%>" fill="black"/>
    <image id="crop" style="pointer-events: none;" width="<%=w%>" height="<%=h%>" fill="black" xlink:href="/<%=image%>"/>  
       
</svg>
        <!-- Button Interface-->
        <div class="container float-left" style=" top: 9%; width: 100%; height: 5%; position: absolute; padding: 5%; margin-left: auto; left: auto; right: auto; border-right: 0%; margin-right: auto;">
            <br/>
            <div class="image-controls">
                <h2 class="text-right float-left" style="position: inherit; left: 7rem;">Tools</h2>
                <br/>
                <table style="width: 25rem; height:100%; table-layout:auto;">
                    <tr>
                    <th colspan="2" class="text-left float-center">
                        <!-- <li><button class="btn btn-primary btn-lg float-center" id="cropFlag"> Crop Image</button></li> -->
                        <!-- <li><button id="backBtn" class="btn btn-secondary btn-lg" onclick="loaderActivate()">Undo Crop</button></li> -->
                        <li><button class="btn btn-secondary btn-lg" onclick="window.history.back();">Back to Caption</button></li>
                        <li><a class="btn btn-primary btn-lg" href="/" role="button">New Upload</a></li>
                        
                        <li><img class="btn btn-primary btn-lg button" id="northIconFlag" style="width:4.5rem;"src="/images/north.png"></img>
                            <label for="northCheckbox">Toggle Color</label>
                            <input class="form-check-input largeBox" type="checkbox" id="northCheckbox">
                            
                        </li>

                        <li><img class="btn btn-primary btn-lg button" id="sunIconFlag" style="width:4.5rem;" src="/images/sun_symbol.png"></img>
                            <label for="sunCheckbox" style="top: 20rem">Toggle Color</label>
                            <input class="form-check-input largeBox" type="checkbox" id="sunCheckbox" style="top: 22.5rem;">
                        </li>
                        <li><img class="btn btn-primary btn-lg button" id="eyeFlag" style="width:4.5rem;" src="/images/eye_symbol.png"></img>
                            <label for="eyeCheckbox" style="top: 20rem">Toggle Color</label>
                            <input class="form-check-input largeBox" type="checkbox" id="eyeCheckbox" style="top: 28rem;">
                        </li>
                        <li><img class="btn btn-primary btn-lg button" id="pencilIconFlag" style="width:4.5rem;"src="/images/pencil.png"></img><input id="colorPickerLine"type="color" name="lineColor"  value="#ff0000"/>  <button class="btn btn-secondary btn-sm" id="undoLine">Undo Line</button></li>
                        <li><button class="btn btn-primary btn-lg button" id="scaleBarButton" style="width:7rem; color: black">Scalebar</button></li>
                        <li><button class="btn btn-primary btn-lg button" id="outlineBtn" style="width:8rem; color: black">Outline Box</button><input id="colorPickerBox"type="color" name="boxColor"  value="black"/> <button class="btn btn-secondary btn-sm" id="undoBox">Undo Box</button></li>
                        <li><button class="btn btn-primary btn-lg button" id="textBtn" style="width:8rem; color: black">Text Box</button>
                            <br/><label for="textColorPicker" style="top: 15rem">Pick Color</label>
                            <input type="color" id="textColorPicker" style="top: 48.5rem; left: 16rem;" value="#FFFFFF">
                            <button class="btn btn-secondary btn-sm" id="undoText">Undo Text</button></li>
                        <li style=" height: 10rem; padding: 0; padding-top: 1rem; padding-left: 5rem;">
                            <h2 class="text-left">Pad Image</h2>
                            <div class="row" style="padding:0; padding-left: 1rem; width: 20rem; height: 4rem;">
                                    <div class="col" style="padding:0;"><input class="form-control form-control-lg" style="width: 14rem;"id="paddingInput" type="text" placeholder="Image Padding (px)"/> </div>
                                    <div class="col" style="padding:0; padding-left: .5rem; padding-top: .5rem"><button  style="left: 15rem; top: 0rem;" class="btn btn-secondary btn-md" id="resetPaddingBtn"> Reset </button> </div>
                            </div>
                        
                            <div class="row" style="padding:0; padding-left: 1rem; width: 20rem;">
                                <div class="col" style="top:0; padding: 0; left: 0rem;"><button style="width: 4.5rem;"class="btn btn-secondary btn-md" id="topPaddingBtn"> Top </button> </div>
                                <div class="col" style="top:0rem; padding: 0; left: 0rem;"><button style="width: 4.5rem;"class="btn btn-secondary btn-md" id="bottomPaddingBtn"> Bottom </button> </div>
                            
                                <div class="col"style="top:0rem;padding: 0; left: 0rem;"><button style="width: 4.5rem;" class="btn btn-secondary btn-md" id="leftPaddingBtn"> Left </button> </div>
                                <div class="col"style="text-outline: 0rem; padding: 0; left: 0rem;"><button style="width: 4.5rem;"class="btn btn-secondary btn-md" id="rightPaddingBtn"> Right </button> </div>
                                
                            </div>
                        </li>
                        <li>
                            <div class="row" style="padding:0; padding-left: 1rem; width: 20rem; border: 0px solid blue;">
                                <div class="col" style="padding: 0; top: 0rem">
                                <button class="btn btn-primary btn-lg" id="exportBtn"> Download Figure</button>
                            </div>
                        </div>
                        </li>
                    </th>
                </tr>
            </table>
    </div>
</div>
        
<br/>
        <!-- Hidden Tags for data parsing-->
        <div id="metadata" style="display:none;"  class="text-center green-border-focus">
                <label for="metadata-text">
                    <h2>Metadata Output</h2>
                </label>
                <textarea readonly id="metadata-text" class="form-control bg-white text-dark" style="resize: vertical; font-size: 22px;"><%= tagField %></textarea>
            </div>
        
            <div id="metadata-tags" style="display:none;" class="text-center green-border-focus">
                <label for="metadataTagArea">
                    <h2>Metadata Tags</h2>
                </label>
                <textarea readonly id="metadataTagArea" class="form-control bg-white text-dark" style="resize: vertical; font-size: 22px;"></textarea>
            </div>
            <!-- Canvas for extracting inline svg-->
            <canvas id="canvas" width="<%=w%>" height="<%=h%>" style="display:none; border: 5px solid black; fill: black;" ></canvas>


        <script type="text/javascript">

            // string version of off the icons so they can be added dynamicly with a single function call 
            // (sun and eye) MIN .15625 MAX 1.5625
            var sunObjectString = '<g id="sunPosition" class="draggable confine" transform-origin="50%; 50%;" transform="translate(100,150) rotate(0) scale(.15625)"  stroke-width="7" style="border:0; padding:0; pointer-events:visible;"> '
                    +'<circle id= "sunIconOuter"  r="125" cy="175" cx="150" stroke-width="15" stroke="white" fill="black" style="border:0;"></circle>'
                    +'<circle id= "sunIcon"  r="25" cy="175" cx="150" fill="white" stroke="black" style="border:0;"></circle>'
                    + '<path d="M 150 0 L 250 50 L 150 0 L 50 50 L 150 25 L 250 50" stroke="red" stroke-width="10"/>'
                    +'<rect class="resize top-left"x="0" y="0" width="100" height="100" style="visibility: hidden;"fill="red"/>'
                    +'<rect class="resize top-right"x="220" y="0" width="100" height="100" style="visibility: hidden;"fill="blue"/>'
                    +'<rect class="resize bottom-right"x="220" y="200" width="100" height="100" style="visibility: hidden;"fill="green"/>'
                    +'<rect class="resize bottom-left"x="0" y="200" width="100" height="100" style="visibility: hidden;"fill="yellow"/></g>';
            
            var arrow = '<path id="arrow" x="0" y="0" d="M 150 150 L 150 300 L 150 0 L 300 150 L 150 0 L 0 150" stroke-width="10" stroke="blue"  style="border: 5px solid green;" fill="none"/>'  

            // (North) MIN .1219513 MAX 1.219513
            var northObjectString = '<g id="northPosition" class="draggable confine" transform-origin="50%; 50%;"  transform="translate(100,100) rotate(0) scale(.1219513)" stroke-width="7" style="border:0; padding:0; pointer-events:all;">'
                +'<rect x="0" y="0" id="northBG"style="visibility: visible;"width="200" height="400" fill="black"/>'
                +'<rect x="0" y="0" class="resize top-left" style="visibility: hidden;"width="100" height="125" fill="red"/>'
                +'<rect x="100" y="0" class="resize top-right" style="visibility: hidden;"width="100" height="150" fill="yellow"/>'
                +'<path id= "northIcon"  d="M 100 0 L 200 200 L 100 150 L 0 200 Z" fill="white"  stroke="black" stroke-width="4" style="border:0;"></path>'
                +'<path id="nLetter" d="M 50 200 L 50 0 L 150 200 L 150 0"stroke="white" stroke-width="10" transform="translate(0,200)"fill="black" style="border:0;"></path>'
                +'<rect class= "resize bottom-right"x="100" y="300" width="110" height="110" style="visibility: hidden;"fill="green"/>'
                +'<rect class= "resize bottom-left"x="0" y="300" width="110" height="110" style="visibility: hidden;"fill="blue"/></g>'
                

            var outlineObjectString = '<rect id="cropOutline" x="0" y="0" width="5" height="5" style="fill:rgba(245, 13, 13, 0.15);pointer-events:none; stroke-width:2;stroke:rgb(255,0,0);" />';

            var attensionBoxObjectString ='<rect id="attensionBox" x="0" y="0" width="400" height="400" />'
                + '<rect class=" resize top-left" x="0" y="0" width="125" height="125" style="visibility: hidden;fill:rgba(245, 13, 13, 0.15); stroke-width:2;stroke:blue" />'
                + '<rect class=" resize top-right" x="275" y="0" width="125" height="125" style="visibility: hidden;fill:rgba(245, 13, 13, 0.15); stroke-width:2;stroke:blue" />'
                + '<rect class=" resize bottom-right" x="275" y="275" width="125" height="125" style="visibility: hidden;fill:rgba(245, 13, 13, 0.15); stroke-width:2;stroke:blue" />'
                + '<rect class=" resize bottom-left" x="0" y="275" width="125" height="125" style="visibility: hidden;fill:rgba(245, 13, 13, 0.15); stroke-width:2;stroke:blue" />';
            
            var eyeObjectString = '<g id="eyePosition" class="draggable confine" transform-origin="50%; 50%;" transform="translate(0,100) rotate(0) scale(.15625)" stroke-width="5" style="border:0; padding:0; pointer-events:visible;">'
                + '<ellipse id= "eyeIconOuter"  cx="150" cy="100" rx="150" ry="100" stroke-width="10" stroke="white" fill="black" style="border:0;"></ellipse>'
                + '<circle id= "eyeIconCenter"  r="80"cy="100" cx="150" fill="white" stroke="black"  style="border:0;">'
                + '</circle><circle id= "eyeIconPupel"  r="30"cy="100" cx="150" stroke="white" fill="black"  style="border:0;"></circle>'
                + '<rect x="0" y="-10" class="resize top-left" style="visibility: hidden;"width="100" height="80" fill="red"/>'
                + '<rect x="220" y="-10" class="resize top-right" style="visibility: hidden;"width="100" height="80" fill="blue"/>'
                + '<rect x="220" y="120" class="resize bottom-right" style="visibility: hidden;"width="100" height="100" fill="green"/>'
                + '<rect x="0" y="120" class="resize bottom-left" style="visibility: hidden;"width="95" height="100" fill="yellow"/></g>';
            
            var scaleBarObject = '<g id="scalebarPosition"class="draggable confine scalebar" transform="translate(0,175) scale(.1)" stroke-width="7" style="border:0; padding:0; pointer-events:all;">'
                + '<rect x="0" y="0" id="scalebarBG" width="4000" height="500" stroke="black" fill="red" ></rect>'
                + '<rect x="0" y="200" id="scalebarOuter" width="4000" height="300" stroke="white" fill="black" ></rect>'
                + '<path id="scalebarLine" d="M 2000 350 L 4000 350"  stroke="white" stroke-width="7"/>'
                + '<path id="scalebarVert" d="M 2000 200 L 2000 500"  stroke="white" stroke-width="5"/>'
                + '<path id="scalebarVert10th" d="M 200 200 L 200 500"  stroke="white" stroke-width="5"/>'
                + '<path id="scalebarLine10th" d="M 0 350 L 200 350"  stroke="white" stroke-width="7"/>'

                + '<path id="scalebarVert20th" d="M 400 200 L 400 500"  stroke="white" stroke-width="5"/>'
                + '<path id="scalebarVert30th" d="M 600 200 L 600 500"  stroke="white" stroke-width="5"/>'
                + '<path id="scalebarLine30th" d="M 400 350 L 600 350"  stroke="white" stroke-width="7"/>'

                + '<path id="scalebarVert40th" d="M 800 200 L 800 500"  stroke="white" stroke-width="5"/>'
                + '<path id="scalebarVert50th" d="M 1000 200 L 1000 500"  stroke="white" stroke-width="5"/>'
                + '<path id="scalebarLine50th" d="M 800 350 L 1000 350"  stroke="white" stroke-width="7"/>'

                + '<path id="scalebarVert60th" d="M 1200 200 L 1200 500"  stroke="white" stroke-width="5"/>'
                + '<path id="scalebarVert70th" d="M 1400 200 L 1400 500"  stroke="white" stroke-width="5"/>'
                + '<path id="scalebarLine70th" d="M 1200 350 L 1400 350"  stroke="white" stroke-width="7"/>'

                + '<path id="scalebarVert80th" d="M 1600 200 L 1600 500"  stroke="white" stroke-width="5"/>'
                + '<path id="scalebarVert90th" d="M 1800 200 L 1800 500"  stroke="white" stroke-width="5"/>'
                + '<path id="scalebarLine90th" d="M 1600 350 L 1800 350"  stroke="white" stroke-width="7"/>'

                + '<text id="scalebarText" x="3400" y="150" font-family="sans-serif" font-size="150" stroke="white"fill="white"><%=scalebarLength%> <%=scalebarUnits%></text>'
                + '<text id="scalebar1" x="10" y="150" font-family="sans-serif" font-size="150" stroke="white"fill="white"> <%=scalebarLength%></text>'
                + '<text id="scalebarHalf" x="900" y="150" font-family="sans-serif" font-size="150" stroke="white"fill="white"></text>'
                + '<text id="scalebar0" x="1950" y="150" font-family="sans-serif" font-size="150" stroke="white"fill="white">0</text></g>';


            // grab DOM elements that are needed
            var exportBtn =  document.getElementById('exportBtn');
            var myImage = document.getElementById('crop');
            var svg = document.getElementById('svgWrapper');
            var loader = document.getElementById('loading');
           

            // dynamically add the elements to export better 
            svg.insertAdjacentHTML("beforeend",sunObjectString);
            svg.insertAdjacentHTML("beforeend",arrow);
            var arrowImage = document.getElementById("arrow");
            var sunImage = document.getElementById("sunPosition");
            svg.insertAdjacentHTML("beforeend",northObjectString);
            var northImage = document.getElementById("northPosition");
            svg.insertAdjacentHTML('beforeend',outlineObjectString);
            var outlineBox = document.getElementById('cropOutline');
            svg.insertAdjacentHTML("beforeend",eyeObjectString);
            var eyeImage = document.getElementById('eyePosition');
            svg.insertAdjacentHTML("beforeend",scaleBarObject);
            var scaleBarIcon = document.getElementById('scalebarPosition');
            
           

            
            let half = parseFloat("<%=scalebarLength%>")/2;
            
            let scalePX = parseFloat("<%=scalebarPx%>"),
                w = parseInt("<%=w%>"),
                h = parseInt("<%=h%>"),
                origW = parseInt("<%=origW%>"),
                origH = parseInt("<%=origH%>");
            


            console.log(parseInt("<%= origW %>"))
            console.log(parseInt("<%= origH %>"));
            
            if('<%=scalebarPx%>' !== 'none'){
                if((w/origW) < (h/origH)){
                    scaleBarIcon.setAttribute("transform","translate(0,175) scale(" + (scalePX/4000)* 2 * (w/origW) + ')');
                   
                }else{
                    scaleBarIcon.setAttribute("transform","translate(0,175) scale(" + (scalePX/4000)* 2 * (h/origH) + ')');
                    
                }
                
                
                if(half < 1){
                    document.getElementById("scalebarHalf").innerHTML = half;
                }
                else{
                    document.getElementById("scalebarHalf").innerHTML = parseInt(half);
                }
            }
            else{
                document.getElementById("scaleBarButton").setAttribute("class",document.getElementById("scaleBarButton").getAttribute("class") + " disabled"); 
            }
            

            // grab the image data for changing colors before it is removed
            var sunIconInner = document.getElementById("sunIcon");
            var sunIconOuter = document.getElementById("sunIconOuter");

            var northBG = document.getElementById("northBG");
            var northArrow = document.getElementById("northIcon");
            var northLetter = document.getElementById("nLetter");

            var eyeIconOuter = document.getElementById("eyeIconOuter");
            var eyeIconCenter = document.getElementById("eyeIconCenter");
            var eyePupel = document.getElementById("eyeIconPupel");

            // reove the objects because they are not needed yet
            northImage.remove();
            sunImage.remove();
            outlineBox.remove();
            eyeImage.remove();
            scaleBarIcon.remove();
            
            arrowImage.remove();


            // set defaults
            outlineBox.style.visibility = 'hidden';

            // function to hide the loading gif
            function loadInvisible(){
                loader.style.visibility = 'hidden';    
            }
            // function to show the loading gif
            function loaderActivate(){
                loader.style.visibility = 'visible';
            }

            
            console.log(" image dimensions are => <%= w %>: <%= h %>");
            // set loader to invisible
            loadInvisible();
        
            // toggle colors tracker
            var toggleNorth = true,
                toggleSun = true,
                toggleEye = true,
                toggleScalebar = true,
                userTextColor;


            // everytime  the check boxes is changed switch the places of the fill and stroke
            $("#northCheckbox").on("change",function(){
                if(toggleNorth){
                    northBG.setAttribute("fill","white");
                    northArrow.setAttribute("fill", "black");
                    northArrow.setAttribute("stroke", "white");
                    northLetter.setAttribute("stroke", "black");
                    northLetter.setAttribute("fill","white");
                    toggleNorth = false;
                }else{
                    northBG.setAttribute("fill","black");
                    northArrow.setAttribute("fill", "white");
                    northArrow.setAttribute("stroke", "black");
                    northLetter.setAttribute("stroke", "white");
                    northLetter.setAttribute("fill","black");
                    toggleNorth = true;
                }
            });

            // everytime  the check boxes is changed switch the places of the fill and stroke
            $("#sunCheckbox").on("change",function(){
                if(toggleSun){
                    
                    sunIconInner.setAttribute("fill", "black");
                    sunIconInner.setAttribute("stroke", "white");
                    sunIconOuter.setAttribute("stroke", "black");
                    sunIconOuter.setAttribute("fill","white");
                    toggleSun = false;

                }else{
                    sunIconInner.setAttribute("fill", "white");
                    sunIconInner.setAttribute("stroke", "black");
                    sunIconOuter.setAttribute("stroke", "white");
                    sunIconOuter.setAttribute("fill","black");
                    toggleSun = true;
                }
            });
            // everytime  the check boxes is changed switch the places of the fill and stroke
            $("#eyeCheckbox").on("change",function(){
                if(toggleEye){
                    eyeIconOuter.setAttribute("fill","white");
                    eyeIconOuter.setAttribute("stroke","black");
                    eyeIconCenter.setAttribute("fill", "black");
                    eyeIconCenter.setAttribute("stroke", "white");
                    eyePupel.setAttribute("stroke", "black");
                    eyePupel.setAttribute("fill","white");
                    toggleEye = false;

                }else{
                    eyeIconOuter.setAttribute("fill","black");
                    eyeIconOuter.setAttribute("stroke","white");
                    eyeIconCenter.setAttribute("fill", "white");
                    eyeIconCenter.setAttribute("stroke", "black");
                    eyePupel.setAttribute("stroke", "white");
                    eyePupel.setAttribute("fill","black");
                    toggleEye = true;
                }
            });

            
        
        $("#scaleBarButton").on("click",function(){
            if(!this.classList.contains("disabled")){
                if(toggleScalebar){
                    svg.appendChild(scaleBarIcon);
                    document.getElementById("scaleBarButton").className = "btn btn-secondary btn-lg button";
                    toggleScalebar = false;
                }else{
                    scaleBarIcon.remove();
                    toggleScalebar = true;
                    document.getElementById("scaleBarButton").className = "btn btn-primary btn-lg button";
                }
            }
        });
        
        </script>


        <script type="text/javascript">
            // function to convert client pixel values to svg DOM relative values

            function svgPoint(element, x, y) {
                // get a new svg point
                var pt = svg.createSVGPoint();
                // set the point x value to the passed x
                pt.x = x;
                // same for y
                pt.y = y;

                /* use matrixTransform to convert the x and y using getScreenCTM to capture
                    the browsers coordinate matrix */
                return pt.matrixTransform(element.getScreenCTM().inverse());    
            }
            

            /**
            * converts image to a data url so that when exporting all that is needed 
            * is to convert the svg block to a canvas and then export as an image
            **/
            function getDataUri(url, callback) {
                var image = new Image();

                image.onload = function () {
                    var canvas = document.createElement('canvas');
                    canvas.width = this.naturalWidth; // or 'width' if you want a special/scaled size
                    canvas.height = this.naturalHeight; // or 'height' if you want a special/scaled size

                    canvas.getContext('2d').drawImage(this, 0, 0);

                    // Get raw image data
                    callback(canvas.toDataURL('image/png').replace(/^data:image\/(png|jpg);base64,/, ''));

                    // ... or get as Data URI
                    callback(canvas.toDataURL('image/png'));
                };

                image.src = url;
            }

        </script>

        <script type="text/javascript">

            // set all flags to false to start
            var sunIconPlaced = false,
                northIconPlaced = false,
                eyeIconPlaced = false,
                doneResizing = false,
                northFlag = false,
                cropFlag = false, 
                sunFlag = false,
                eyeFlag = false,
                attensionBoxVisible = false;

            //create clickArray
            var clickArray = [];

            // on doc ready run the button logic and click capturing events
            $(document).ready(function() {
                // reset click array on a new load
                clickArray = [];
                var svgDOM = document.getElementById('svgWrapper');
                makeDraggable(svgDOM);
                var myImage = document.getElementById('crop');

                // convert image to data Base64
                getDataUri('/<%=image%>', function(dataUri) {
                    myImage.setAttribute('xlink:href',dataUri);
                });
                
                // get padding input box and other important DOM elements for export
                var paddingBoxInput = document.getElementById("paddingInput");
                var bg = document.getElementById("svgBackground");
                var canvas = document.getElementById("canvas");
                
                // init the padding value
                paddingBoxInput.value = '';
                
                // function that adjusts the view box and background to add padding to the image
                function setImagePadding(val,location){
                    // image w and h vars
                    let imageW;
                    let imageH;


                    // switch on the location of the padding
                    switch(location){
                        // if bottom padding
                        case 'bottom':
                            // get the new image height for the box and background
                            imageH = <%=h%> + val; 
                            // set the viewbox values to how on the bottom of the image
                            svgDOM.setAttribute("viewBox", "0 0 <%=w%> " + imageH);

                            // set background x,y to 0 to show at the bottom of the image
                            bg.setAttribute("x",0);
                            bg.setAttribute("y",0);

                            // adjust the height and set the width to what it should be
                            bg.setAttribute("height", imageH);
                            bg.setAttribute("width",<%=w%>);
                            // same with canvas to allow exporting the padding
                            canvas.setAttribute("height", imageH);
                            canvas.setAttribute("width",<%=w%>);
                            // fix the svg to properly export all content
                            svgDOM.setAttribute("height", imageH);
                            svgDOM.setAttribute("width",<%=w%>);
                            // call makeDraggable again to reset the boundaries of the draggable elements
                            makeDraggable(svgDOM);
                            break;

                        case "top":
                            // get the new image height for the box and background
                            imageH = <%=h%> + val;
                            // set background x,y to show padding at the right spot
                            bg.setAttribute("y",val*-1);
                            bg.setAttribute("x",0);
                            // adjust the height and set the width to what it should be
                            bg.setAttribute("height",imageH);
                            bg.setAttribute("height",<%=w%>);
                            
                            // set the viewbox values 
                            svgDOM.setAttribute("viewBox", "0 " + String(val*-1) + " <%=w%> " + imageH);
                            // same with canvas to allow exporting the padding
                            canvas.setAttribute("height", imageH);
                            canvas.setAttribute("width",<%=w%>);
                            // fix the svg to properly export all content
                            svgDOM.setAttribute("height", imageH);
                            svgDOM.setAttribute("width",<%=w%>);
                            // call makeDraggable again to reset the boundaries of the draggable elements
                            makeDraggable(svgDOM);
                            break;

                        case "right":
                            // get the new image width for the box and background
                            imageW = <%=w%> + val;
                            // set background x,y to padding at the right spot
                            bg.setAttribute("y",0);
                            bg.setAttribute("x",0);
                            // adjust the height and set the width to what it should be
                            bg.setAttribute("width",imageW);
                            bg.setAttribute("height",<%=h%>);
                            
                            // set the viewbox values
                            svgDOM.setAttribute("viewBox", "0 0 "  + imageW + " <%=h%>");
                            // same with canvas to allow exporting the padding
                            canvas.setAttribute("width", imageW);
                            canvas.setAttribute("height",<%=h%>);
                            // fix the svg to properly export all content
                            svgDOM.setAttribute("width", imageW);
                            svgDOM.setAttribute("height",<%=h%>);
                            // call makeDraggable again to reset the boundaries of the draggable elements
                            makeDraggable(svgDOM);
                            break;


                        case "left":
                            // get the new image width for the box and background
                            imageW = <%=w%> + val;
                            // set background x,y to padding at the right spot
                            bg.setAttribute("y",0);
                            bg.setAttribute("x",val*-1);
                            // adjust the height and set the width to what it should be
                            bg.setAttribute("width",imageW);
                            bg.setAttribute("height",<%=h%>);
                            
                            // set the viewbox values 
                            svgDOM.setAttribute("viewBox",  String(val*-1)+ " 0 "  + imageW + " <%=h%>");
                            // same with canvas to allow exporting the padding
                            canvas.setAttribute("width", imageW);
                            canvas.setAttribute("height",<%=h%>);
                            // fix the svg to properly export all content
                            svgDOM.setAttribute("width", imageW);
                            svgDOM.setAttribute("height",<%=h%>);
                            // call makeDraggable again to reset the boundaries of the draggable elements
                            makeDraggable(svgDOM);
                            break;

                        default:
                            // get the new image width and height for the box and background
                            imageW = <%=w%>;
                            imageH = <%=h%>; 

                            // set background x,y to padding at the right spot                            
                            bg.setAttribute("x",0);
                            bg.setAttribute("y",0);
                            // adjust the height and set the width to what it should be
                            bg.setAttribute("width",imageW);
                            bg.setAttribute("height",imageH);

                            // set the viewbox values
                            svgDOM.setAttribute("viewBox", "0 0 <%=w%> <%=h%>");
                            // same with canvas to allow exporting the padding
                            canvas.setAttribute("width", <%=w%>);
                            canvas.setAttribute("height",<%=h%>);
                            // fix the svg to properly export all content
                            svgDOM.setAttribute("width", <%=w%>);
                            svgDOM.setAttribute("height",<%=h%>);
                            // call makeDraggable again to reset the boundaries of the draggable elements
                            makeDraggable(svgDOM);

                    }
                        
                    
                }

                // jquery to detect a click on the padding buttons 
                $("#bottomPaddingBtn").on('click',function(event){
                    if(!isNaN(parseInt(paddingBoxInput.value))){
                        setImagePadding(parseInt(paddingBoxInput.value),'bottom');
                    }else{
                        setImagePadding(parseInt(0),"none");   
                    }
                });

                $("#topPaddingBtn").on('click',function(event){
                    if(!isNaN(parseInt(paddingBoxInput.value))){
                        setImagePadding(parseInt(paddingBoxInput.value),'top');
                    }else{
                        setImagePadding(parseInt(0),"none");   
                    }
                });

                $("#rightPaddingBtn").on('click',function(event){
                   
                    if(!isNaN(parseInt(paddingBoxInput.value))){
                        setImagePadding(parseInt(paddingBoxInput.value),'right');
                    }else{
                        setImagePadding(parseInt(0),"none");   
                    } 
               });

               $("#leftPaddingBtn").on('click',function(event){
                   
                   if(!isNaN(parseInt(paddingBoxInput.value))){
                       setImagePadding(parseInt(paddingBoxInput.value),'left');
                   }else{
                       setImagePadding(parseInt(0),"none");   
                   } 
              });

                $("#resetPaddingBtn").on('click',function(event){
                   
                    setImagePadding(parseInt(0),"none"); 
                    paddingBoxInput.value = "";  
                    
                });
/* 
                // when the image registers a click
                $("image").on("click", function(event) {
                    event.preventDefault();
                    // capture event variables for px calculations
                    var t = event.target;
                    var x = event.pageX;
                    var y = event.pageY;
                
                    // if the target is the svg DOM then keep it the same 
                      //  otherwise set it to the parent of the current target 
                    var target = (t == svg ? svg : t.parentNode);
                    // get the converted svg coordinates
                    var svgP = svgPoint(target, x, y);
                    // convert floats to integers
                    var x = parseInt(svgP.x),
                        y = parseInt(svgP.y);
                
                    // ======== FOR TESTING=======
                    console.log("x is: " + x);
                    console.log("y is:" + y);
                    // ===========================

                    /* // if any of the flags are true
                    if(cropFlag){

                        // and if the click array is either length = 0 or the clicks are in 
                           // a proper location for cropping capture the click in the clickArray 
                        if(clickArray.length === 0){
                            captureClick(x,y);
                            // check click array
                            console.log(clickArray);
                        }else if(clickArray.length === 2){
                            
                            captureClick(x,y);
                            prepareCrop(clickArray);
                            
                            
                        }
                        
                        // Then if the click flag is true and the length of the array is 2
                        if(cropFlag && clickArray.length === 2){
                            // set the dimensions and visibilty of the outline box
                            outlineBox.style.visibility = 'visible';
                            svg.insert(outlineBox);
                            
                            outlineBox.setAttribute('x',clickArray[0]);
                            outlineBox.setAttribute('y',clickArray[1]);
                        }
                        // if the crop flag is true and the length of the click array is 4 crop the image
                        else if( cropFlag && clickArray.length === 4){
                            // activate loader gif 
                            loaderActivate();
                            // set done resizeing flag
                            doneResizing = true;
                            //get the array string for the request
                            let arrayStr = clickArray.toString();
                            // prevent defaults 
                            event.preventDefault();
                            // send ajax POST request through http
                            $.ajax({
                                type: 'POST',
                                cache: false,
                                async: true,
                                url: 'http://localhost:8080/crop?cropArray=' + arrayStr + '&currentImage=' +'<%= image %>',
                                success: function(response) { 
                                    // on success load the new html data into the page    
                                    $("html").html(response);
                                    // set the loader to invisible
                                    loadInvisible();
                                    // reset clickarray
                                    clickArray = [];
                                    // reset flag
                                    cropFlag = false;
                                },
                                error: function(xhr, status, err) {
                                    // on error log the error
                                    console.log(xhr.responseText);
                                    alert('Crop Failed');
                                    loadInvisible();
                                }
                            });
                            
                        }
                    }  
                }); // end image click
 */
                // set values for calculating outline box size 
                var mouseX,
                    mouseY,
                    startX,
                    startY;
                    
                    
                // ready the cropArray before pasing the points ion the required order
                // must be done this way because we cannot pass negative width and height values
                function prepareCrop(clickArray){
                    var startX = clickArray[0],
                        startY = clickArray[1],
                        endX = clickArray[2],
                        endY = clickArray[3];

                    if(startX > endX && startY > endY){
                        clickArray[0] = endX;
                        clickArray[1] = endY;
                        clickArray[2] = startX;
                        clickArray[3] = startY;
                    }
                    else if(startX > endX || startY > endY){
                        if(startX > endX){
                            clickArray[0] = startX - (startX - endX);
                            clickArray[2] = endX + (startX - endX);
                        }
                        else{
                            
                            clickArray[1] = startY - (startY - endY);
                            clickArray[3] = endY + (startY - endY);
                        }
                    }

                    return clickArray;
                }

               /*  // capture mouse position on image mouse over
                $('#crop').mousemove(function(event){
                    event.preventDefault();

                    // set event variables
                    var t = event.target;
                    var x = event.clientX;
                    var y = event.clientY;
                
                    // get proper svg as target
                    var target = (t == svg ? svg : t.parentNode);
                    
                    // get new svg relative point
                    var svgP = svgPoint(target, x, y);
                    // convert to int
                    mouseX = parseInt(svgP.x),
                    mouseY = parseInt(svgP.y);

                    console.log( "mouse over image: " + mouseX +': ' + mouseY);
                    
                    // only adjust the box if currently croppping
                    if(!doneResizing && clickArray.length > 1){
                        
                        adjustBox();
                    }
                }); */

                var line,
                    lineArr = [],
                    userLineColor;
                 
                $('#svgWrapper').on("click", function(event){
                    
                    // set event variables
                    var t = event.target;
                    var x = event.clientX;
                    var y = event.clientY;
                    // TODO: figure our how to buffer the Y portion
                    var bufferY = parseInt(Number(<%=h%>) * .09);
                    // get proper svg as target
                    var target = (t == svg ? svg : t.parentNode);
                    
                    // get new svg relative point
                    var svgP = svgPoint(target, x, y);
                    // convert to int
                    mouseX = parseInt(svgP.x),
                    mouseY = parseInt(svgP.y);
                    
                    console.log('MOUSE CLICK ON SVG Outer BOX: '+ mouseX + ' '+ mouseY);

                    // if the draw flag is true and length of clicks is 0
                    if(drawFlag && clickArray.length === 0){
                        line = document.createElementNS("http://www.w3.org/2000/svg","line");
                        line.setAttribute("x1",mouseX);
                        line.setAttribute("y1",mouseY);
                        line.setAttribute("x2",mouseX);
                        line.setAttribute("y2",mouseY);
                        line.style.visibility = "visible";
                        if(userLineColor){
                            line.style.stroke = userLineColor;
                        }else{
                            line.style.stroke = "red";
                        }
                        
                        line.style.strokeWidth = 4;
                        svg.appendChild(line);


                        lineArr.push(line);
                        captureClick(mouseX,mouseY);
                    }
                    else if(drawFlag && clickArray.length > 1){
                        line.setAttribute("x2",mouseX);
                        line.setAttribute("y2",mouseY);
            
                        clickArray = [];
                        drawFlag = false;
                        document.getElementById("pencilIconFlag").className = "btn btn-primary btn-lg button";
                        svg.className.baseVal = "image-image float-center";

                        
                        let svgElements = svg.childNodes;
                        console.log(svgElements);
                        for(index in svgElements){
                            if(svgElements[index].classList && svgElements[index].classList.contains("draggable")){
                                svgElements[index].style.pointerEvents = "visible";
                                if(svgElements[index].childNodes){
                                    for(index2 in svgElements[index].childNodes){
                                        if(svgElements[index].childNodes[index2].classList && svgElements[index].childNodes[index2].classList.contains("resize")){
                                            svgElements[index].childNodes[index2].style.pointerEvents = "painted";
                                        }
                                    }
                                }
                            }
                        }
                    }
                   
                 /*   COMMENTING OUT FOR NOW
                     if(cropFlag){
                        // clicking close to the 0,0
                        if(mouseX < 0 && mouseY < bufferY){
                            captureClick(0,0);
                        }
                        // if the click is close to max corner(bottom right)
                        else if(mouseY > Number(<%=h%>) - bufferY && mouseX > Number(<%=w%>)){
                            captureClick(<%=w%>,<%=h%>);
                        }
                        // if the click is close to the top right 
                        else if(mouseX > Number(<%=w%>) && mouseY < bufferY){
                            captureClick(<%=w%>,0);
                        }
                        // if the click is close to bottom left corner
                        else if(mouseX < 0 && mouseY > Number(<%=h%>) - bufferY){
                            captureClick(0,<%=h%>);
                        }
                        // for left side
                        else if(mouseX < 0 && mouseY < Number(<%=h%>) - bufferY){
                            captureClick(0,mouseY);
                        }
                        // for right side
                        else if(mouseX > Number(<%=w%>) && mouseY < Number(<%=h%>) - bufferY && mouseY > bufferY){
                            captureClick(<%=w%>,mouseY);
                        }

                        if(!doneResizing){
                                console.log(clickArray);
                            outlineBox.style.visibility = 'visible';
                            svg.appendChild(outlineBox);
                            outlineBox.setAttribute('x',clickArray[0]);
                            outlineBox.setAttribute('y',clickArray[1]);
                        }

                        if(clickArray.length === 4){
                            // and if the points arent stacked
                            if((clickArray[0] === clickArray[2] && clickArray[0] !== 0) || clickArray[1] === clickArray[3]){
                                clickArray = [];
                                alert('Cannot be cropped in this manner');
                                cropFlag = false;
                                document.getElementById('cropFlag').innerHTML = "Crop Image";
                            
                            }
                            else{
                                prepareCrop(clickArray);
                                // activate loader gif 
                                loaderActivate();
                                // set done resizeing flag
                                doneResizing = true;
                                //get the array string for the request
                                let arrayStr = clickArray.toString();
                                // prevent defaults 
                                event.preventDefault();
                                // send ajax POST request through http
                                $.ajax({
                                    type: 'POST',
                                    cache: false,
                                    async: true,
                                    url: 'http://localhost:8080/crop?cropArray=' + arrayStr + '&currentImage=' +'<%= image %>',
                                    success: function(response) { 
                                        // on success load the new html data into the page    
                                        $("html").html(response);
                                        // set the loader to invisible
                                        loadInvisible();
                                        // reset clickarray
                                        clickArray = [];
                                        // reset flag
                                        cropFlag = false;
                                    },
                                    error: function(xhr, status, err) {
                                        // on error log the error
                                        console.log(xhr.responseText);
                                        alert('Crop Failed');
                                        loadInvisible();
                                    }
                                });
                            }
                        } 
                        
                        
                    }
                     */
                });


 
                function drawLine(lineElement,x2,y2){
                    lineElement.setAttribute("x2", x2);
                    lineElement.setAttribute("y2",y2);
                }


                 $('#svgWrapper').mousemove(function(event){
                    

                        // set event variables
                        var t = event.target;
                        var x = event.clientX;
                        var y = event.clientY;
                        // TODO: figure our how to buffer the Y portion
                        var bufferY = 50;
                        // get proper svg as target
                        var target = (t == svg ? svg : t.parentNode);
                        
                        
                        // get new svg relative point
                        var svgP = svgPoint(target, x, y);
                        // convert to int
                        mouseX = parseInt(svgP.x),
                        mouseY = parseInt(svgP.y);

                        //console.log('MOUSE MOVING OVER SVG BOX: ' + mouseX + ': ' + mouseY);
                        if( drawFlag && clickArray.length >1){
                            
                            drawLine(line, mouseX, mouseY);
                        }
                        
                        
/*
                    if(cropFlag && !doneResizing){


                        // clicking close to the 0,0
                        if(mouseX < 0 && mouseY < bufferY){
                            mouseX = 0;
                            mouseY = 0;
                        }
                        // if the click is close to max corner(bottom right)
                        else if(mouseY > Number(<%=h%>) - bufferY && mouseX > Number(<%=w%>)){
                            mouseX = <%=w%>;
                            mouseY = <%=h%>;
                        }
                        // if the click is close to the top right 
                        else if(mouseX > Number(<%=w%>) && mouseY < bufferY){
                            mouseX = <%=w%>;
                            mouseY = 0;
                        }
                        // if the click is close to bottom left corner
                        else if(mouseX < 0 && mouseY > Number(<%=h%>) - bufferY){
                            mouseX = 0;
                            mouseY = <%=h%>;
                        }
                        // for left side
                        else if(mouseX < 0 && mouseY < Number(<%=h%>) - bufferY){
                            mouseX = 0;
                            
                        }
                        // for right side
                        else if(mouseX > Number(<%=w%>) && mouseY < Number(<%=h%>) - bufferY && mouseY > bufferY){
                            mouseX = <%=w%>;
                        }
                        adjustBox();
                    }*/
                }); 
            
                // function to change the outline box dimensions to the calulated size
                function adjustBox(){

                    // get start points of the crop
                    startX = clickArray[0];
                    startY = clickArray[1];

                    // convert number and do the math
                    let w = Number(mouseX) - startX;
                    let h = Number(mouseY) - startY;
                    
                    // reset the outline box if the values are not NaN
                    if(w !== NaN && h !== NaN){
                        if(w < 0 && h < 0){
                            h = Math.abs(h);
                            w = Math.abs(w);
                            

                            outlineBox.setAttribute('x' , startX  - w);
                            outlineBox.setAttribute('y' , startY - h);
                            outlineBox.setAttribute('width' , w);
                            outlineBox.setAttribute('height' , h);
                        }else if(w < 0 || h < 0){
                            if(w<0){
                                w = Math.abs(w);

                                outlineBox.setAttribute('x' , startX  - w);
                                outlineBox.setAttribute('y' , startY);
                                
                            }else{
                                h = Math.abs(h);
                                outlineBox.setAttribute('x' , startX);
                                outlineBox.setAttribute('y' , startY - h);
                            }
                            outlineBox.setAttribute('width' , w);
                            outlineBox.setAttribute('height' , h);
                        }else{
                            outlineBox.setAttribute('width' , w);
                            outlineBox.setAttribute('height' , h);
                        }
                        
                    }
                } 


                var highlightBoxArray = [],
                    userBoxColor;
                // when the outline box is clicked
                $("#outlineBtn").on("mousedown",function(){
                    
                    var g = document.createElementNS("http://www.w3.org/2000/svg","g");

                    

                    g.setAttribute("class","draggable confine outline");
                    g.setAttribute("transform-origin","50%; 50%;");
                    g.setAttribute("transform","translate(0,0) rotate(0) scale(.5)");
                    g.setAttribute("stroke-width","7");
                    g.style.border = 0;
                    g.style.padding = 0;
                    g.style.pointerEvents = "visible";

                    g.innerHTML = attensionBoxObjectString;
                    
                    console.log(userBoxColor);
                    if(userBoxColor){
                        g.style.fill = userBoxColor;
                        g.style.opacity =.27;
                        
                    }else{
                        g.style.fill = "black";
                        g.style.opacity =.27;
                    }
                    svg.appendChild(g);
                    highlightBoxArray.push(g);
                    makeDraggable(svg);
                });


                var textBoxArray = [];
                // when the text box is clicked
                $("#textBtn").on("mousedown",function(){
                    
                    var textboxVal = prompt("What Should It Say?","");

                    if(textboxVal !== ""){
                        console.log(textboxVal + "= textboxVal");

                        var text = document.createElementNS("http://www.w3.org/2000/svg","text");
                        text.setAttribute("class","draggable confine textbox");
                        text.setAttribute("x",0);
                        text.setAttribute("y",0);
                        text.setAttribute("transform","translate(50,50) rotate(0) scale(1)");
                        text.style.pointerEvents = "visible";
                        text.innerHTML = textboxVal;

                        if(userTextColor){
                            text.setAttribute("stroke",userTextColor);
                            text.setAttribute("fill",userTextColor);
                        
                        }else{
                            text.setAttribute("stroke","white");
                            text.setAttribute("fill","white");
                        
                        }


                        text.setAttribute("stroke-width","1");
                        svg.appendChild(text);
                        textBoxArray.push(text);
                        makeDraggable(svg);
                        

                    }
                });


                // everytime  the check boxes is changed switch the places of the fill and stroke
                $("#textColorPicker").on("change",function(){
                    console.log("change colors");
                    userTextColor = document.getElementById("textColorPicker").value;
                });
        



                $("#undoText").on("mousedown",function(){
                    
                    if(textBoxArray.length > 0){
                        textBoxArray.pop().remove();
                    }else{
                        alert("text has not been added");
                    }
                });
                var drawFlag = false;

                $("#pencilIconFlag").on('mousedown',function(){
                    if(drawFlag){
                        drawFlag = false;
                        
                        svg.className.baseVal = "image-image float-center";
                        document.getElementById("pencilIconFlag").className = "btn btn-primary btn-lg button";
                        clickArray = [];
                        if(lineArr.length && clickArray > 1){
                            lineArr.pop().remove();
                        }

                        let svgElements = svg.childNodes;
                        console.log(svgElements);
                        for(index in svgElements){
                            if(svgElements[index].classList && svgElements[index].classList.contains("draggable")){
                                svgElements[index].style.pointerEvents = "visible";
                                if(svgElements[index].childNodes){
                                    for(index2 in svgElements[index].childNodes){
                                        if(svgElements[index].childNodes[index2].classList && svgElements[index].childNodes[index2].classList.contains("resize")){
                                            svgElements[index].childNodes[index2].style.pointerEvents = "painted";
                                        }
                                    }
                                }
                            }
                        }


                    }
                    else{
                        svg.className.baseVal = "image-image float-center draw";
                        drawFlag = true;
                        document.getElementById("pencilIconFlag").className = "btn btn-secondary btn-lg button";


                        let svgElements = svg.childNodes;
                        console.log(svgElements);
                        for(index in svgElements){
                            if(svgElements[index].classList && svgElements[index].classList.contains("draggable")){
                                svgElements[index].style.pointerEvents = "none";
                                if(svgElements[index].childNodes){
                                    for(index2 in svgElements[index].childNodes){
                                        if(svgElements[index].childNodes[index2].classList && svgElements[index].childNodes[index2].classList.contains("resize")){
                                            svgElements[index].childNodes[index2].style.pointerEvents = "none";
                                        }
                                    }
                                }
                            }
                        }

                        
                    }
                });


                $("#undoBox").on("mousedown",function(){
                    if(highlightBoxArray.length > 0){
                        highlightBoxArray.pop().remove();
                    }else{
                        alert("There are no boxes placed yet");
                    }
                });


                $("#undoLine").on("mousedown",function(){
                    if(lineArr.length > 0 && clickArray.length > 1){
                        lineArr.pop().remove();
                        svg.className.baseVal = "image-image float-center";
                        document.getElementById("pencilIconFlag").className = "btn btn-primary btn-lg button";
                        drawFlag = false;
                        clickArray = [];
                    }
                    else if(lineArr.length > 0){
                        lineArr.pop().remove();
                    }
                    else{
                        alert("No lines drawn");
                    }
                });


                $("#colorPickerLine").change(function(){
                    userLineColor = document.getElementById("colorPickerLine").value;
                });
                $("#colorPickerBox").change(function(){
                    userBoxColor = document.getElementById("colorPickerBox").value;
                });




                // when north button is clicked
                $('#northIconFlag').on('mousedown',function(){
                    if(!document.getElementById("northIconFlag").classList.contains("disabled")){
                        // change north flag
                        northFlag = !northFlag;
                        
                        // if north flag is placed currently remove it
                        if(northIconPlaced){
                            northIconPlaced = !northIconPlaced;
                            northImage.remove();
                            northImage.style.visibility = 'hidden';
                            document.getElementById('northIconFlag').setAttribute('class',"btn btn-primary btn-lg button");
                            northImage.setAttribute("transform","translate(100,100) rotate(0) scale(.121952)");
                            
                            northFlag = !northFlag;
                        }
                        
                        // otherwise set the other flags to false and adjust their html
                        if(northFlag){
                            if(!sunIconPlaced){
                                sunFlag = false;
                                document.getElementById('sunIconFlag').innerHTML = "Add Sun Icon";
                            }

                            if(!eyeIconPlaced){
                                eyeFlag = false;
                                document.getElementById('eyeFlag').innerHTML = "Add Observer Icon";
                            }

                            /* cropFlag = false;
                            document.getElementById('cropFlag').innerHTML = "Crop Image"; */
                            outlineBox.remove();
                            outlineBox.style.visibility = 'hidden';
                            
                            svg.appendChild(northImage);
                            northImage.style.visibility = 'visible';
                            setIconAngle(northImage, northDegree);
                            makeDraggable(svg);
                            northIconPlaced = !northIconPlaced;
                            northFlag = false;
                            document.getElementById('northIconFlag').setAttribute('class',"btn btn-secondary btn-lg button");
                        }
                        
                        clickArray = [];
                    }
                    
                }); 


                // use same logic for other button
                $('#eyeFlag').click(function(){
                    if(!document.getElementById("eyeFlag").classList.contains("disabled")){
                        eyeFlag = !eyeFlag;

                        if(eyeIconPlaced){
                            eyeIconPlaced = !eyeIconPlaced;
                            eyeImage.remove();
                            eyeImage.style.visibility = 'hidden';
                            eyeFlag = !eyeFlag;
                            document.getElementById('eyeFlag').setAttribute('class',"btn btn-primary btn-lg button");
                            eyeImage.setAttribute("transform","translate(0,100) scale(.15625)");
                        }

                        if(eyeFlag){
                            
                            cropFlag = false;
                        /*  document.getElementById('cropFlag').innerHTML = "Crop Image"; */
                            outlineBox.remove();
                            outlineBox.style.visibility = 'hidden';
                            
                            svg.appendChild(eyeImage);
                            eyeImage.style.visibility = 'visible'
                            document.getElementById('eyeFlag').setAttribute('class',"btn btn-secondary btn-lg button");
                            eyeFlag = false;
                            eyeIconPlaced = true;
                        }
                    } 
                });

                // use same logic for other button
                $('#sunIconFlag').click(function(){
                    
                    if(!document.getElementById("sunIconFlag").classList.contains("disabled")){
                        sunFlag = !sunFlag;

                        if(sunIconPlaced){
                            sunIconPlaced = !sunIconPlaced;
                            sunImage.style.visibility = 'hidden';
                            sunImage.remove();
                            document.getElementById('sunIconFlag').setAttribute('class',"btn btn-primary btn-lg button");
                            sunFlag = false;
                            sunImage.setAttribute("transform","translate(150,150) rotate(0) scale(.15625)");
                            arrowImage.remove();

                           
                                
                        }
                        
                        if(sunFlag){
                            
                            cropFlag = false;
                            outlineBox.style.visibility = 'hidden';
                            
                        /*  document.getElementById('cropFlag').innerHTML = "Crop Image"; */
                            sunImage.style.visibility = 'visible';
                            svg.appendChild(sunImage);
                            sunFlag = false;
                            sunIconPlaced = true;
                            document.getElementById('sunIconFlag').setAttribute('class',"btn btn-secondary btn-lg button");
                            
                            setIconAngle(sunImage, sunDegree);
                            makeDraggable(svg);  
                            
                            //sunImage.appendChild(arrowImage);
                            
                        }
                        
                        clickArray = [];
                    }
                    
                });



                function drawArrow(icon, rotationVal){
                    let transString = icon.getAttribute("transform").split(" ")[0];
                    let scaleString = icon.getAttribute("transform").split(" ")[icon.getAttribute("transform").split(" ").length -1];
                    

                    var x = transString.split(",")[0].replace("translate("," "),
                        y = transString.split(",")[1].replace(")"," "),
                        scale = scaleString.split("scale(")[1].replace(")"," ");

                    if(icon.id.indexOf('sun') > -1){
                       
                        arrowImage.style.transformOrigin = String(Number(x) + " " + Number(y) - (icon.getBBox().height * scale/2));
                        
                        arrowImage.setAttribute("transform","translate(" + String(Number(x) - (icon.getBBox().width * scale/2)) + " " + String(Number(y) - (icon.getBBox().height * scale/2)) 
                        + ") rotate("+ 45 + ")"); 
                
                    }else{
                        // draw on the eye
                    }
                }



/* 
                // use same logic for other button
                $("#cropFlag").click(function(){
                    cropFlag = !cropFlag;

                    if(cropFlag){
                        if(!northIconPlaced){
                            northFlag = false
                            document.getElementById('northIconFlag').innerHTML = "Add North Arrow";
                        }
                        if(!sunIconPlaced){
                            sunFlag = false;
                            document.getElementById('sunIconFlag').innerHTML = "Add Sun Icon";
                        }
                        if(eyeFlag && !eyeIconPlaced){
                            eyeFlag = false;
                            document.getElementById('eyeFlag').innerHTML = "Add Observer Icon";
                        }

                        document.getElementById('cropFlag').innerHTML = "Cancel?";
                        
                    }else{
                        clickArray = [];
                        document.getElementById('cropFlag').innerHTML = "Crop Image";
                        outlineBox.style.visibility = 'hidden';
                    }
                    
                }); */




/* 
                // button to undo the cropped image
                $("#backBtn").on('click',function(event){
                    event.preventDefault();

                    var currentImg = '<%= image %>';

                    console.log(currentImg);

                    // if the image has been cropped then get the previous image
                    if(currentImg.indexOf('_crop.png') > -1){
                        // ajax request for the data sending the current image link
                        $.ajax({
                            type: 'GET',
                            
                            cache: false,
                            url: 'http://localhost:8080/crop?currentImage=' +'<%= image %>',
                            success: function(response) {
                                $("html").html(response);
                            
                                
                            },
                            error: function(xhr, status, err) {
                                console.log(xhr.responseText);
                                loadInvisible();
                                
                            }
                        });
                    }else{
                        // if the current image is the base image then alert the user
                        loadInvisible();
                        alert('Base Image:\nCannot Be Undone');
                    }

                    
                }); */
            
            }); // end doc.ready
            
            // function to push the x,y coordinates into the clickArray
            function captureClick(x,y){
                clickArray.push(x);
                clickArray.push(y);
            }

            
            // Export Section

            // download works well for pngs
            function triggerDownload (imgURI,filename) {
                var event = new MouseEvent('click', {
                    view: window,
                    bubbles: false,
                    cancelable: true
                });
                var a = document.createElement('a');
                a.setAttribute('download', filename);
                a.setAttribute('href', imgURI);
                a.setAttribute('target', '_blank');

                a.dispatchEvent(event);
            }

            
            // when the export is clicked
            exportBtn.addEventListener('click', function () {
                
                // get the svg element and the canvas information
                canvas = document.getElementById('canvas');
                var ctx = canvas.getContext('2d');

                var data = (new XMLSerializer()).serializeToString(svg);
                var DOMURL = window.URL || window.webkitURL || window;

                // creates new image from svg inline elements excludiong the actual image
                var img = new Image();
                var svgBlob = new Blob([data], {type: 'image/svg+xml;charset=utf-8'});
                var url = DOMURL.createObjectURL(svgBlob);

                
                img.onload = function(){
                    // draw the svg image onto the canvas
                    ctx.drawImage(img,0,0);
                    
                    // if the filename a false value
                    if(!filename){
                        // read in a filename with prompt
                        var filename = prompt("Save File as png svg or jpeg","");
                    }

                    // if the filename is one of the accepted filenames and it isnt null              
                    if( filename !== null && /^.*\.(png|PNG|JPEG|jpeg|JPG|jpg|SVG|svg)$/gm.test(filename)){
                        var fileExt = filename.split(".")[filename.split(".").length - 1];

                        // if the fileExt is NOT svg
                        if(fileExt !== 'svg'){
                            try{
                                if(fileExt === 'jpg'){
                                    // export an image of the extension type
                                    var imgURI = canvas
                                    .toDataURL('image/jpeg', 1.0)
                                    .replace('image/jpeg', 'image/octet-stream');
                                }
                                else{
                                    // export an image of the extension type
                                    var imgURI = canvas
                                    .toDataURL('image/'+fileExt, 1.0)
                                    .replace('image/'+fileExt, 'image/octet-stream');
                                }
                                
                                // start the download
                                triggerDownload(imgURI,filename);            
                            }catch(err){
                                alert('Image is too large to save from browser');
                            }
                        }else{
                            // fileExt === 'svg'
                            try{
                                // trigger the download with the svg url instead of converting to image
                                triggerDownload(url,filename);       
                            }catch(err){
                                alert('Image is too large to save from browser');
                            }

                        }
                    }
                    // must enter an accepted fileExt
                    else if(filename !== null){
                       exportBtn.click();
                    }
                    // revoke the url
                    DOMURL.revokeObjectURL(url);

                    // Note:
                    //     if the user hits cancel the filename will be null, we ignore this case
                };
                // set the img src to the url
                try{
                    img.src = url;
                }catch(err){
                    console.log('source could not be located');
                }
            });
        </script>

        <!-- Legend Section-->
        <br/>
        <div class="position-relative text-center" style="margin-left:auto; margin-right:auto; display: none;">
            <h2 style="padding-top:1%;padding-bottom:1%; margin-bottom: 0%;">Image Legend</h2>
            <table class="float-center text-center" style="margin-left:auto; margin-right:auto; margin-top: 0px;">
                <tr>
                    <td>
                        <svg id="legend-image" width="450" height="200">
                            <rect width="100%" height="100%" rx="10" ry="10" style="fill:rgb(233, 236, 239);">
                            </rect>
                            <foreignObject x="10" y="10" width="100%" height="100%">
                                <table class="float-center" id="legend-table">
                                    <tr id="north">
                                        <th>North:</th>
                                        <th><img id="northImg" src="images/north.png" width="25" preserveAspectratio="xMaxYMid meet" height="25"><img/></th>
                                        <th id="northDeg">0 degrees</th>
                                    </tr>
                                    <tr id="sun-az">
                                        <th>Sun Azimuthal Direction:</th>
                                        <th><img id="sunImg" src="images/sun_symbol.png" width="25" height="25"></img></th>
                                        <th id="sunDeg">0 degrees</th>
                                    </tr>
                                    <tr id="obs-az">
                                        <th>Observer Azimuthal Direction:</th>
                                        <th><img id="observerImg" src="images/eye_symbol.png" width="25" height="25"></img></th>
                                        <th id="obsDeg">0 degrees</th>
                                    </tr>
                                    <tr id="image-scalebar" style="overflow:hidden;">
                                        <th>Scalebar:</th>
                                        <th><img src="images/arrow.png" width="25" height="25"></img></th>
                                        <th id="scaleDeg">0 degrees</th>
                                    </tr>   
                                </table>
                            </foreignObject>
                            <line id="observerArrow" x1="0" y1="0" x2="50" y2="0" style="stroke:rgb(255,0,0);stroke-width:2; display:none;"/>
                            <line id="sunArrow" x1="0" y1="0" x2="50" y2="0" style="stroke:rgb(255,0,0);stroke-width:2; display:none;"/>
                        </svg>
                    </td>
                    <td valign="top">
                        <div class="float-center" style="align-content: center; width: 300px; height: auto; margin: auto;">
                            <div id="hide-legend" class="float-center" style="text-align: left;">
                                <table style="text-align:left;">
                                    <tr><h4>Hide Legend Elements</h4></tr>
                                    <tr><input type="checkbox" id="north-radio" name="leg" checked>North Arrow</input><br/></tr>
                                    <tr><input type="checkbox" id="sun-radio" name="leg" checked>Sun Azimuthal Direction</input><br/></tr>
                                    <tr><input type="checkbox" id="obs-radio" name="leg" checked>Observer Azimuthal Direction</input><br/></tr>
                                    <tr><input type="checkbox" id="scalebar-radio" name="leg" checked>Scalebar</input><br/></tr>
                                </table>
                            </div>
                        </div>
                    </td>
                </tr>
            </table>
        </div>
        <br/>
        <br/>
        <br/>
         
        <!-- Exporting The Legend-->
        <div id="legend-export-div" style="margin-left:35%;">
        </div>
                                                                    
        <script>
            function exportLegend(){
                var div = document.getElementById("legend-export-div");
                html2canvas(document.querySelector("#legend-table")).then(function(canvas) {
                    document.getElementById("legend-export-div").append(canvas);        
                    //document.body.appendChild(canvas);
                });
            }
        </script>
        <script>
            function hideNorth(){
                document.getElementById("north").style.display = "none";
                //console.log("Hiding North");
            }
            function showNorth(){
                document.getElementById("north").style.display = "table-row";
                //console.log("Showing North");
            }
            function hideSun(){
                document.getElementById("sun-az").style.display = "none";
            }
            function showSun(){
                document.getElementById("sun-az").style.display = "table-row";
            }
            function hideObs(){
                document.getElementById("obs-az").style.display = "none";
            }
            function showObs(){
                document.getElementById("obs-az").style.display = "table-row";
            }
            function hideScale(){
                document.getElementById("image-scalebar").style.display = "none";
                //console.log("Showinfgejnhfkjshdf");
            }
            function showScale(){
                document.getElementById("image-scalebar").style.display = "table-row";
                //console.log("actually show");
            }

            // function to hide the elements in the legend area
            function showHide(){
                var northRadio = document.getElementById("north-radio").checked;
                var sunRadio = document.getElementById("sun-radio").checked;
                var obsRadio = document.getElementById("obs-radio").checked;
                var scalebarRadio = document.getElementById("scalebar-radio").checked;
                if(!northRadio){
                    hideNorth();
                }else{
                    showNorth();
                }
                if(!sunRadio){
                    hideSun();
                }else{
                    showSun();
                }
                if(!obsRadio){
                    hideObs();
                }else{
                    showObs();
                }
                if(!scalebarRadio){
                    hideScale();
                }else{
                    showScale();
                }
            }
            setInterval(showHide, 1000);
        </script>

        <script>
            
            var northDegree,
                sunDegree,
                observerDegree;

            var placeEnum = new Object({
                        "top-left":1,
                        "top-right":2,
                        "bottom-right":3,
                        "bottom-left":4
                        });
        

            Object.prototype.getNameWithVal = function(val){
                let tmpArr = Object.keys(this);
                for(key in tmpArr){
                    if( this[tmpArr[key]] === val){
                        return tmpArr[key];
                    }
                }
            }


            // Gets Important Metadata from the "metadata-text" div
            function getMetadata(){
                // get value string from hidden DOM element
                var metadata = document.getElementById("metadata-text").innerHTML;
                // parse back into JSON
                var metadataString = JSON.parse(metadata);
                
                // Important Metadata Values
                northDegree = parseFloat(metadataString['NorthAzimuth']);
                sunDegree = parseFloat(metadataString['SubSolarAzimuth']);
                observerDegree = parseFloat(metadataString['SubSpacecraftGroundAzimuth']);
                
                
                // TODO: generate an arrow in the proper direction in relation to the degree of the sun and eye angles
                if(isNaN(northDegree)){
                    document.getElementById("north-radio").checked = false;
                    document.getElementById('northIconFlag').setAttribute('class',"btn btn-primary btn-lg button disabled");
                    
                }else{
                    setLegendAngle("northImg", "northDeg", northDegree);
                }

                if(isNaN(sunDegree)){
                    document.getElementById("sun-radio").checked = false;
                    document.getElementById('sunIconFlag').setAttribute('class',"btn btn-primary btn-lg button disabled");
                }

                if(isNaN(observerDegree)){
                    document.getElementById("obs-radio").checked = false;
                    document.getElementById('eyeFlag').setAttribute('class',"btn btn-primary btn-lg button disabled");
                }




                setScaleboxCorners(northDegree, sunDegree);
            }

            // set the arrow directions and recieve the data
            getMetadata();
            

            

            function setScaleboxCorners(northDegree, sunDegree){
                
                if(!isNaN(northDegree) &&  northDegree!== 0){
                    let childList = northImage.childNodes;
                    let offset90 = Math.round(northDegree / 90);
                    let offset45 = northDegree / 45;

                    console.log("offset 90 is: "+ offset90 )
                    for(index in childList){
                        if(childList[index].classList && childList[index].classList.contains("resize") && offset90 >= 1 && offset90 <= 4){
                            
                            if(childList[index].classList.contains("top-left")){
                                let newClass = placeEnum["top-left"] + offset90;
                                if(newClass > 4){newClass -= 4}
                                

                                childList[index].setAttribute("class","resize " + placeEnum.getNameWithVal(newClass));
                            }
                            else if(childList[index].classList.contains("top-right")){
                                let newClass = placeEnum["top-right"] + offset90;
                                if(newClass > 4){newClass -= 4}
                                

                                childList[index].setAttribute("class","resize " + placeEnum.getNameWithVal(newClass));
                            }
                            else if(childList[index].classList.contains("bottom-right")){
                                let newClass = placeEnum["bottom-right"] + offset90;
                                if(newClass > 4){newClass -= 4}
                                

                                childList[index].setAttribute("class","resize " + placeEnum.getNameWithVal(newClass));
                            }
                            else if(childList[index].classList.contains("bottom-left")){
                                let newClass = placeEnum["bottom-left"] + offset90;
                                if(newClass > 4){newClass -= 4}
                                

                                childList[index].setAttribute("class","resize " + placeEnum.getNameWithVal(newClass));
                            }
                        }
                        
                    }
                }
                if(!isNaN(sunDegree)){
                    let childList = sunImage.childNodes;
                    let offset90 = parseInt(sunDegree / 90);
                    console.log(offset90);
                    for(index in childList){
                        if(childList[index].classList && childList[index].classList.contains("resize") && offset90 >= 1 && offset90 <= 3){
                            console.log("found corner");
                            if(childList[index].classList.contains("top-left")){
                                let newClass = placeEnum["top-left"] + offset90;
                                if(newClass > 4){newClass -= 4}
                                

                                childList[index].setAttribute("class","resize " + placeEnum.getNameWithVal(newClass));
                            }
                            else if(childList[index].classList.contains("top-right")){
                                let newClass = placeEnum["top-right"] + offset90;
                                if(newClass > 4){newClass -= 4}
                                

                                childList[index].setAttribute("class","resize " + placeEnum.getNameWithVal(newClass));
                            }
                            else if(childList[index].classList.contains("bottom-right")){
                                let newClass = placeEnum["bottom-right"] + offset90;
                                if(newClass > 4){newClass -= 4}
                                

                                childList[index].setAttribute("class","resize " + placeEnum.getNameWithVal(newClass));
                            }
                            else if(childList[index].classList.contains("bottom-left")){
                                let newClass = placeEnum["bottom-left"] + offset90;
                                if(newClass > 4){newClass -= 4}
                                

                                childList[index].setAttribute("class","resize " + placeEnum.getNameWithVal(newClass));
                            }
                        }
                    }
                }
            }



            

            // Set Legend North Angle Angle
            function setLegendAngle(img, degree, value){
                // get the image element and the element to display the angle degree
                let image = document.getElementById(String(img));
                let deg = document.getElementById(String(degree));
                // rotate the value using css transform
                let rotateVal = String("transform: rotate(" + String(value) + "deg);");
                // transform about the origin
                image.setAttribute("transform-origin", "50%; 50%;");
                // change the html angle display
                deg.innerHTML = String(value) + "degrees";

                // set the new style for the image
                image.setAttribute("style", rotateVal);
            }

            // Generate Arrow Legend Icons
            function setLegendArrow(img, arrow, deg, value){
                var image = document.getElementById(String(img));
                //var arrow = document.getElementById();
            }

            function setIconAngle(icon, degree){

                console.log(degree);
                if(!isNaN(degree)){
                    let transformVal = icon.getAttribute("transform");
                    let transformArray = transformVal.split(" ");

                    for(index in transformArray){
                        if(transformArray[index].indexOf("rotate") > -1){
                            var tmp = transformArray[index].split("rotate(")[1];
                            
                            tmp = tmp.replace(")"," ").trim();
                            tmp = degree;
                            transformArray[index] = "rotate("+ tmp +")";
                            
                            icon.setAttribute("transform", transformArray.join(" "));
                            return;
                        }

                    }

                    let scaleStr = transformArray[transformArray.length -1];
                    let translateStr = transformArray[0];

                    let rotateStr = "rotate(" + String(degree) + ")";

                    transformArray.pop();
                    transformArray.push(rotateStr);
                    transformArray.push(scaleStr);
                    
                    icon.setAttribute("transform", transformArray.join(" "));
                    
                }

            }
            
            // draw an arrow and rotate the arrow for the eye not the actual eye 
            // setIconAngle(eyeImage, observerDegree);


        /*  //========== This Function is for testing the Rotation Orgin Point ===============
            i = 0;
            setInterval(function(){
                i += 1;
                setLegendAngle("northImg", "northDeg", i);
            }, 1000);
            //============================================================================ */
        </script>
        
    </body>
</html>

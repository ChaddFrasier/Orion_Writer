<html>
    <head>
        <!-- Required meta tags -->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=yes">

        <link rel="stylesheet", href="css/pips.css" type="text/css">

        <!-- Bootstrap CSS -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
            integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

        <title>Image Edit</title>

        <script src="http://ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js"></script>
    </head>
<!--  FOR TESTING WILL MOVE TO CSS FILE LATER -->
    <style>
        
    </style>
<!--============================================= -->
<script>
    // function to create a draggable field from svg element
    function makeDraggable(event) {
    
        // get svg element
        var svg = event;
    
        // adds event functions to the whole svg element
        svg.addEventListener('mousedown', startDrag);
        svg.addEventListener('mousemove', drag);
        svg.addEventListener('mouseup', endDrag);
        svg.addEventListener('mouseleave', endDrag);
        
        // decrale all global function variables for dragging
        var selectedElement, offset, transform,
            bbox, minX, maxX, minY, maxY, confined;
        // & for resizing
        var resizing = false,
            dragging = false,
            currentScale,
            transformString,
            startH,
            startW,
            minNorth = .1219513,
            maxNorth = 1.219513,
            minSun = .15625,
            maxSun = 1.5625,
            minEye = .15625,
            maxEye = 1.5625,
            iconMin,
            scale;
        
            
        // sets boundries for draggable objects when confined based on the view box
        // minX = x of viewbox
        var boundaryX1 = Number(svg.getAttribute('viewBox').split(" ")[0]);
        // maxX = the width of the viewbox - the absolute value of the x value
        var boundaryX2 = Number(svg.getAttribute('viewBox').split(" ")[2]) - Math.abs(Number(svg.getAttribute('viewBox').split(" ")[0]));
        // minY = y of the viewBox
        var boundaryY1 = Number(svg.getAttribute('viewBox').split(" ")[1]);
        // maxY = the height of the viewbox - the absolute value of the  y of the view box
        var boundaryY2 = Number(svg.getAttribute('viewBox').split(" ")[3]) - Math.abs(Number(svg.getAttribute('viewBox').split(" ")[1]));

        // get the mouse position relative to the svg screen matrix
        // math functions were found on a blog post
        function getMousePosition(event) {
            var CTM = svg.getScreenCTM();
            
            return {
                x: (event.clientX - CTM.e) / CTM.a,
                y: (event.clientY - CTM.f) / CTM.d
            };
        }

        // start the drag on mousedown
        function startDrag(event){
            // get the mouseX and mouseY on the client
            mX = event.clientX, mY = event.clientY;
            // prevent all other mousedown events
            event.preventDefault();
            // find what element the event is on
            var elementOver = document.elementFromPoint(mX,mY);
            // get the element that needs to be dragged or scaled
            selectedElement = event.target.parentNode;
            // grab the limits scale value for whichever icon is selected
            // functions find min if passed true and find max if passed false
            iconMin = findLimit(selectedElement,true);
            iconMax = findLimit(selectedElement, false);
            // get the bounding box of the group element
            bbox = selectedElement.getBBox();
            // Make sure the first transform on the element is a translate transform
            var transforms = selectedElement.transform.baseVal;

            // get scale data
            scale = transforms.getItem(transforms.length -1);

            console.log(bbox.width * scale.matrix.a);
            console.log(bbox.height * scale.matrix.a);

            // if the element that the mousedown happened over is a resize block and the function is not currently resizing,
            // start resize logic
            if(elementOver.classList.contains('resize') && !resizing){
                // set resizing flag
                resizing = true;
            
                // get the coordinates where the click happend inside the svg box
                offset = getMousePosition(event);

                // get the transform string so we can change it later strip the scale part off the end because we are resizing
                transformString = selectedElement.getAttribute("transform").split("scale(")[0];
                
                // extract the scale value as a number
                currentScale = scale.matrix.a;

                console.log(scale.matrix.a);
                
                // get translate data
                transform = transforms.getItem(0);


            }
            // if the event click happened on a draggable element start drag logic
            else if (event.target.parentNode.classList.contains('draggable')) {
                // set dragging flag
                dragging = true;
                // get the offset value for the translation
                offset = getMousePosition(event);

                // make sure that the first element of the tranform object is the translate and create one if it isnt there
                if (transforms.length === 0 || transforms.getItem(0).type !== SVGTransform.SVG_TRANSFORM_TRANSLATE) {
                // sets current transform position to 0,0 to make moving item easier
                var translate = svg.createSVGTransform();
                translate.setTranslate(0, 0);
                selectedElement.transform.baseVal.insertItemBefore(translate, 0);
                }

                // Get initial translation in relation to the current mouse position (offset) and the current translation
                transform = transforms.getItem(0);

                // calculate the transform location in relation to the svg element
                offset.x -= transform.matrix.e;
                offset.y -= transform.matrix.f;

                // is the selected item confined?
                confined = event.target.parentNode.classList.contains('confine');

                // if true
                if (confined) {
                    
                    // get the current scale of the icon
                    let scaleFactor = scale.matrix.a;
                    
                    // set the new boundry values based on the view box and the width/height of the icons
                    // dim * scale = dim of icon
                    minX = boundaryX1 - bbox.x;
                    maxX = boundaryX2 - bbox.x - bbox.width * scaleFactor;
                    minY = boundaryY1 - bbox.y;
                    maxY = boundaryY2 - bbox.y - bbox.height * scaleFactor;

                    //console.log('BOUNDING DIMENSIONS ARE: ' + minX + ' ' + minY +' ' +maxX + ' ' + maxY  );
                }
            }
        }

        // set flags for rescale
        var bottomL = false,
            bottomR = false,
            topR = false,
            topL = false;
        
        // move the icon when mouse moves or scale the icon when needed

        /* IMORTANT: 
            In order to scale the icon in a manner that looks and feels natural for the user
                I am calculating the staring width and height of the icon and shifting the translate by that much
                This gives the illusion that the  icon is growing from the side they are dragging from
            */
        function drag(event) {
            // get the mouse x and y based on client
            mX = event.clientX, mY = event.clientY;

            // set the factor at which the resize happens
            let growingFactor = .02;
            // get the element that the mouse is over
            var elementOver = document.elementFromPoint(mX,mY);
            // prevent all other mousemove events
            event.preventDefault();
            
            // if the selectedElement is not null and resizing is true and dragging is false
            if(selectedElement && resizing && !dragging){
         
                // get new mouse position in svg space
                var coord = getMousePosition(event);

                // calculate icon size using bbox height and width times the scale 
                startH = bbox.height * currentScale;
                startW = bbox.width * currentScale;

                
                // first make sure there are no other flags active and
                // either the top right element is moused over or the top right is being moved
                if((!topL && !bottomL && !bottomR) && (elementOver.classList.contains('top-right') || topR)){
                    //set the flag just incase it isn't
                    topR = true;
                    // if the new x is less  & the new y is greater than the old position then shrink
                    if(coord.x < offset.x && coord.y > offset.y){
                        // decrement by the growing factor
                        currentScale -= growingFactor;
                        // check for the min
                        if(currentScale < iconMin){currentScale = iconMin;}

                        // translate the icon 0 in the x direction and by the difference in the positive y direction
                        dx = parseInt(transform.matrix.e);
                        dy = parseInt(transform.matrix.f + Math.abs(startH - bbox.height * currentScale));
                    }
                    // if the old x is greater and the new y is smaller then we are growing
                    else if(coord.x > offset.x && coord.y < offset.y){
                        // increment by the factor
                        currentScale += growingFactor;

                        // check for max size
                        if(currentScale > iconMax){currentScale = iconMax;}
                        
                        // translate the icon 0 in the x direction and by the difference in the negative y direction        
                        dx = parseInt(transform.matrix.e);
                        dy = parseInt(transform.matrix.f - Math.abs(startH - bbox.height * currentScale));

                       
                    }

                    // set scale using svg data method
                    scale.setScale(currentScale,currentScale);
                    // if parse it returns a true value for both
                    if(dx && dy){
                        // set the new translate
                        transform.setTranslate(dx,dy);
                    }
                    // set the new mouse position as the old so we can scale up and down
                    offset = coord;
                }
                // using the same logic for other corners of the scale
                else if((!topR && !bottomL && !bottomR) && (elementOver.classList.contains('top-left') || topL)){
                    topL = true;
                    // if new x is greater than the old & the new y is greater than the old
                    // shrink the scale
                    if(coord.x > offset.x && coord.y > offset.y){
                        currentScale -= growingFactor;
                        // check for min
                        if(currentScale < iconMin){currentScale = iconMin;}

                        // transform the icon by the positive difference in the sizes                        
                        dx = parseInt(transform.matrix.e + Math.abs(startW - bbox.width * currentScale));
                        dy = parseInt(transform.matrix.f + Math.abs(startH - bbox.height * currentScale));
                    }
                    // if the new x and new y are both less than the old position
                    // grow
                    else if(coord.x < offset.x && coord.y < offset.y){
                        currentScale += growingFactor;


                        // check for max size
                        if(currentScale > iconMax){currentScale = iconMax;}

                        // transform the icon by the negative difference in the sizes
                        dx = parseInt(transform.matrix.e - Math.abs(startW - bbox.width * currentScale));
                        dy = parseInt(transform.matrix.f - Math.abs(startH - bbox.height * currentScale));
                    }

                    // set scale using svg data method
                    scale.setScale(currentScale,currentScale);
                    // if parse it returns a true value for both
                    if(dx && dy){
                        // set the new translate
                        transform.setTranslate(dx,dy);
                    }

                    // set new mouse position
                    offset = coord;
                }
                // same logic as other corners
                else if((!bottomR && !topR && !topL) && (elementOver.classList.contains('bottom-left') || bottomL)){
                    bottomL = true;
                    // if new x is greater and new y is less
                    // shrink
                    if(coord.x > offset.x && coord.y < offset.y){
                        currentScale -= growingFactor;
                        // check for min
                        if(currentScale < iconMin){currentScale =iconMin;}

                        // transform the icon by the negative difference in the sizes keep y the same
                        dx = parseInt(transform.matrix.e + Math.abs(startW - bbox.width * currentScale));
                        dy = parseInt(transform.matrix.f);


                    }
                    // of the new x is less and the new y is greater
                    // grow the icon
                    else if(coord.x < offset.x && coord.y > offset.y){
                        currentScale += growingFactor;

                        // check for max size
                        if(currentScale > iconMax){currentScale = iconMax;}
                        
                        // transform the icon by the negative difference in the sizes keep y the same
                        dx = parseInt(transform.matrix.e - Math.abs(startW - bbox.width * currentScale));
                        dy = parseInt(transform.matrix.f);

                    }
                    
                    // set scale using svg data method
                    scale.setScale(currentScale,currentScale);
                    // if parse it returns a true value for both
                    if(dx && dy){
                        // set the new translate
                        transform.setTranslate(dx,dy);
                    }

                    // set new mouse position
                    offset = coord;
                }
                // same logic as other corners 
                else if((!topL && !topR && !bottomL) && (elementOver.classList.contains('bottom-right') || bottomR)){
                    bottomR = true;
                    // if the new x is less and the new y is also less
                    // shrink
                    if(coord.x < offset.x && coord.y < offset.y){
                        currentScale -= growingFactor;
                        // check min bound
                        if(currentScale < iconMin){currentScale = iconMin;}
                    }
                    // if the new x is greater than the old and the new y is greater
                    // grow
                    else if(coord.x > offset.x && coord.y > offset.y){
                        currentScale += growingFactor;

                        //check for max size
                        if(currentScale > iconMax){currentScale = iconMax;}
                    }
                    // set scale using svg data method
                    scale.setScale(currentScale,currentScale);
                    // no need to translate for bottom right corner

                    // set new mouse coordinates
                    offset = coord;
                }
                       
            }
            // if the selected element is not null and the dragging flag is true
            else if (selectedElement && dragging) {
             
                // get mouse coordinates
                var coord = getMousePosition(event);
                // calculate the difference in the two
                var dx = coord.x - offset.x;
                var dy = coord.y - offset.y;

                // if the icon is confined check for boundry values
                if (confined) {
                    if (dx < minX) { dx = minX; }
                    else if (dx > maxX) { dx = maxX; }
                    if (dy < minY) { dy = minY; }
                    else if (dy > maxY) { dy = maxY; }
                }
                // set the transform
                transform.setTranslate(dx, dy);
            }
        }

        // when mouseup or mouse leave the svg box reset all flags 
        // and set the selectedElement to null
        function endDrag(event) {
            
            if(selectedElement){
                drag(event);
                resizing = false;
                dragging = false;
                bottomL = false;
                bottomR = false;
                topL = false;
                topR = false;
            }
          selectedElement = null;
        }

        // given an icon element returnns the min scale value for each icon to test against the new scale
        function findLimit(selectedElement, isMin){
            if(isMin){
                if(selectedElement.id.indexOf('north') !== -1){
                    return minNorth;
                }
                else if(selectedElement.id.indexOf('sun') !== -1){
                    return minSun;
                }
                else if(selectedElement.id.indexOf('eye') !== -1){
                    return minEye;
                }
            }
            else{
                if(selectedElement.id.indexOf('north') !== -1){
                    return maxNorth;
                }
                else if(selectedElement.id.indexOf('sun') !== -1){
                    return maxSun;
                }
                else if(selectedElement.id.indexOf('eye') !== -1){
                    return maxEye;
                }
            }
        }        
    }// end make dragable

</script>

    <body>
        <!-- Page Header Block-->
        <img src="../images/usgsLogo.png" class="float-md-left" width="10%" height="auto" style="margin: 0%; padding: 0%">
        <div class="container">
            <div class="jumbotron text-center" >
                <h2>Edit the Cube Image</h2>      
                </div>
            </div>
        </div>

        <!-- Loading GIF-->
        <div id="loading" class="float-md-right lead" style="visibility:visible">
            <img src="../images/loading.gif" class='float-center;' height="125px" weight="135px"/><br/>Loading
        </div>
        
        <!-- Button Interface-->
        <div class="container float-left" style="width: auto; height: 5%; position: fixed; padding: 5%; margin-left: auto; left: auto; right: auto; border-right: 0%; margin-right: auto;">
            <br/>
            <div class="image-controls">
                <h2 class="text-right float-left" style="position: inherit; left: 25%;">Tools</h2>
                <br/>
                <table style="width: 100%; height:100%; table-layout:auto;">
                    <tr>
                    <th colspan="1" class="text-left float-center">
                        <!-- <li><button class="btn btn-primary btn-lg float-center" id="cropFlag"> Crop Image</button></li> -->
                        <!-- <li><button id="backBtn" class="btn btn-secondary btn-lg" onclick="loaderActivate()">Undo Crop</button></li> -->
                        <li><button class="btn btn-secondary btn-lg" onclick="window.history.back();">Back to Caption</button></li>
                        <li><a class="btn btn-primary btn-lg" href="/" role="button">New Upload</a></li>
                        
                        <li><img class="btn btn-primary btn-lg button" id="northIconFlag" style="width:4.5rem;"src="/images/north.png"></img></li>
                        <li><img class="btn btn-primary btn-lg button" id="sunIconFlag" style="width:4.5rem;" src="/images/sun_symbol.png"></img></li>
                        <li><img class="btn btn-primary btn-lg button" id="eyeFlag" style="width:4.5rem;" src="/images/eye_symbol.png"></img></li>

                        <li style=" height: 10rem; padding: 0; padding-top: 1rem; padding-left: 5rem;">
                            <h2 class="text-left">Pad Image</h2>
                            <div class="row" style="padding:0; padding-left: 1rem; width: 20rem; height: 4rem;">
                                    <div class="col" style="padding:0;"><input class="form-control form-control-lg" style="width: 14rem;"id="paddingInput" type="text" placeholder="Image Padding (px)"/> </div>
                                    <div class="col" style="padding:0; padding-left: .5rem; padding-top: .5rem"><button  style="left: 15rem; top: 0rem;" class="btn btn-secondary btn-md" id="resetPaddingBtn"> Reset </button> </div>
                            </div>
                        
                            <div class="row" style="padding:0; padding-left: 1rem; width: 20rem;">
                                <div class="col" style="top:0; padding: 0; left: 0rem;"><button style="width: 4.5rem;"class="btn btn-secondary btn-md" id="topPaddingBtn"> Top </button> </div>
                                <div class="col" style="top:0rem; padding: 0; left: 0rem;"><button style="width: 4.5rem;"class="btn btn-secondary btn-md" id="bottomPaddingBtn"> Bottom </button> </div>
                            
                                <div class="col"style="top:0rem;padding: 0; left: 0rem;"><button style="width: 4.5rem;" class="btn btn-secondary btn-md" id="leftPaddingBtn"> Left </button> </div>
                                <div class="col"style="text-outline: 0rem; padding: 0; left: 0rem;"><button style="width: 4.5rem;"class="btn btn-secondary btn-md" id="rightPaddingBtn"> Right </button> </div>
                                
                            </div>
                        </li>
                        <li>
                            <div class="row" style="padding:0; padding-left: 1rem; width: 20rem; border: 0px solid blue;">
                                <div class="col" style="padding: 0; top: 0rem">
                                <button class="btn btn-primary btn-lg" id="exportBtn"> Download Figure</button>
                            </div>
                        </div>
                        </li>
                    </th>
                </tr>
            </table>
    </div>
</div>
        
        <!-- Editor Box -->
        <svg id="svgWrapper" xmlns="http://www.w3.org/2000/svg" version='1.1' stroke="black" fill="black"  xmlns:xlink="http://www.w3.org/1999/xlink" 
        class="image-image float-center" viewBox="0 0 <%=w%> <%=h%>" style="fill:black;" width='<%=w%>' height='<%=h%>'> 
            <rect id="svgBackground" x="0" y="0" width="<%=w%>" height="<%=h%>" fill="red"/>
            <image id="crop" style="pointer-events: none;" width="<%=w%>" height="<%=h%>" fill="black" xlink:href="/<%=image%>"/>    
        </svg>
        
   
<br/>
        <!-- Hidden Tags for data parsing-->
        <div id="metadata" style="display:none;"  class="text-center green-border-focus">
                <label for="metadata-text">
                    <h2>Metadata Output</h2>
                </label>
                <textarea readonly id="metadata-text" class="form-control bg-white text-dark" style="resize: vertical; font-size: 22px;"><%= tagField %></textarea>
            </div>
        
            <div id="metadata-tags" style="display:none;" class="text-center green-border-focus">
                <label for="metadataTagArea">
                    <h2>Metadata Tags</h2>
                </label>
                <textarea readonly id="metadataTagArea" class="form-control bg-white text-dark" style="resize: vertical; font-size: 22px;"></textarea>
            </div>
            <!-- Canvas for extracting inline svg-->
            <canvas id="canvas" width="<%=w%>" height="<%=h%>" style="display:none; border: 5px solid black; fill: black;" ></canvas>


        <script type="text/javascript">

            // string version of off the icons so they can be added dynamicly with a single function call 

            // (sun and eye) MIN .15625 MAX 1.5625
            var sunObjectString = '<g id="sunPosition" class="draggable confine" transform="translate(0,150) scale(.15625 )"  style="border:0; padding:0; pointer-events:visible;"> '
                    +'<circle id= "sunIconOutter"  r="150" cy="150" cx="150" stroke-width="15" stroke="white" fill="black" style="border:0;"></circle>'
                    +'<circle id= "sunIcon"  r="35" cy="150" cx="150" fill="white" stroke="black" style="border:0;"></circle>'
                    +'<rect class="resize top-left"x="0" y="0" width="100" height="100" style="visibility: hidden;"fill="red"/>'
                    +'<rect class="resize top-right"x="220" y="0" width="100" height="100" style="visibility: hidden;"fill="blue"/>'
                    +'<rect class="resize bottom-right"x="220" y="200" width="100" height="100" style="visibility: hidden;"fill="green"/>'
                    +'<rect class="resize bottom-left"x="0" y="200" width="100" height="100" style="visibility: hidden;"fill="yellow"/></g>';
            
            // (North) MIN .1219513 MAX 1.219513
            var northObjectString = '<g id="northPosition" class="draggable confine" transform="translate(0,0) scale(.1219513)" stroke-width="7" style="border:0; padding:0; pointer-events:all;">'
                +'<rect x="0" y="0" style="visibility: visible;"width="200" height="400" fill="black"/>'
                +'<rect x="0" y="0" class="resize top-left" style="visibility: hidden;"width="100" height="125" fill="red"/>'
                +'<rect x="100" y="0" class="resize top-right" style="visibility: hidden;"width="100" height="150" fill="yellow"/>'
                +'<path id= "northIcon"  d="M 100 0 L 200 200 L 100 150 L 0 200 Z" fill="white" stroke="black" stroke-width="4" style="border:0;"></path>'
                +'<path d="M 50 200 L 50 0 L 150 200 L 150 0"stroke="white" stroke-width="10" transform="translate(0,200)"fill="black" style="border:0;"></path>'
                +'<rect class= "resize bottom-left"x="0" y="300" width="110" height="110" style="visibility: hidden;"fill="blue"/>'
                +'<rect class= "resize bottom-right"x="100" y="300" width="110" height="110" style="visibility: hidden;"fill="green"/></g>'

            var outlineObjectString = '<rect id="cropOutline" x="0" y="0" width="5" height="5" style="fill:rgba(245, 13, 13, 0.15);pointer-events:none; stroke-width:2;stroke:rgb(255,0,0);" />';
            
            var eyeObjectString = '<g id="eyePosition" class="draggable confine" transform="translate(0,100) scale(.15625)" stroke-width="5" style="border:0; padding:0; pointer-events:visible;">'
                + '<ellipse id= "eyeIconOutter"  cx="150" cy="100" rx="150" ry="100" stroke-width="10" stroke="white" fill="black" style="border:0;"></ellipse>'
                + '<circle id= "eyeIconCenter"  r="80"cy="100" cx="150" fill="white"  style="border:0;">'
                + '</circle><circle id= "eyeIconPupel"  r="30"cy="100" cx="150" fill="black"  style="border:0;"></circle>'
                + '<rect x="0" y="-10" class="resize top-left" style="visibility: hidden;"width="100" height="80" fill="red"/>'
                + '<rect x="220" y="-10" class="resize top-right" style="visibility: hidden;"width="100" height="80" fill="blue"/>'
                + '<rect x="220" y="120" class="resize bottom-right" style="visibility: hidden;"width="100" height="100" fill="green"/>'
                + '<rect x="0" y="120" class="resize bottom-left" style="visibility: hidden;"width="95" height="100" fill="yellow"/></g>';
            
            // grab DOM elements that are needed
            var exportBtn =  document.getElementById('exportBtn');
            var myImage = document.getElementById('crop');
            var svg = document.getElementById('svgWrapper');
            var loader = document.getElementById('loading');
           

            // dynamically add the elements to export better 
            svg.insertAdjacentHTML("beforeend",sunObjectString);
            var sunImage = document.getElementById("sunPosition");
            svg.insertAdjacentHTML("beforeend",northObjectString);
            var northImage = document.getElementById("northPosition");
            svg.insertAdjacentHTML('beforeend',outlineObjectString);
            var outlineBox = document.getElementById('cropOutline');
            svg.insertAdjacentHTML("beforeend",eyeObjectString);
            var eyeImage = document.getElementById('eyePosition');

            northImage.remove();
            sunImage.remove();
            outlineBox.remove();
            eyeImage.remove();


            // set defaults
            outlineBox.style.visibility = 'hidden';

            // function to hide the loading gif
            function loadInvisible(){
                loader.style.visibility = 'hidden';    
            }
            // function to show the loading gif
            function loaderActivate(){
                loader.style.visibility = 'visible';
            }

            
            console.log(" image dimensions are => <%= w %>: <%= h %>");
            // set loader to invisible
            loadInvisible();
        </script>


        <script type="text/javascript">
            // function to convert client pixel values to svg DOM relative values

            function svgPoint(element, x, y) {
                // get a new svg point
                var pt = svg.createSVGPoint();
                // set the point x value to the passed x
                pt.x = x;
                // same for y
                pt.y = y;

                /* use matrixTransform to convert the x and y using getScreenCTM to capture
                    the browsers coordinate matrix */
                return pt.matrixTransform(element.getScreenCTM().inverse());    
            }
            

            /**
            * converts image to a data url so that when exporting all that is needed 
            * is to convert the svg block to a canvas and then export as an image
            **/
            function getDataUri(url, callback) {
                var image = new Image();

                image.onload = function () {
                    var canvas = document.createElement('canvas');
                    canvas.width = this.naturalWidth; // or 'width' if you want a special/scaled size
                    canvas.height = this.naturalHeight; // or 'height' if you want a special/scaled size

                    canvas.getContext('2d').drawImage(this, 0, 0);

                    // Get raw image data
                    callback(canvas.toDataURL('image/png').replace(/^data:image\/(png|jpg);base64,/, ''));

                    // ... or get as Data URI
                    callback(canvas.toDataURL('image/png'));
                };

                image.src = url;
            }

        </script>

        <script type="text/javascript">

            // set all flags to false to start
            var sunIconPlaced = false,
                northIconPlaced = false,
                eyeIconPlaced = false,
                doneResizing = false,
                northFlag = false,
                cropFlag = false, 
                sunFlag = false,
                eyeFlag = false;

            //create clickArray
            var clickArray = [];

            // on doc ready run the button logic and click capturing events
            $(document).ready(function() {
                // reset click array on a new load
                clickArray = [];
                var svgDOM = document.getElementById('svgWrapper');
                makeDraggable(svgDOM);

                // convert image to data Base64
                getDataUri('/<%=image%>', function(dataUri) {
                    myImage.setAttribute('xlink:href',dataUri);
                });
                
                // get padding input box and other important DOM elements for export
                var paddingBoxInput = document.getElementById("paddingInput");
                var bg = document.getElementById("svgBackground");
                var canvas = document.getElementById("canvas");
                
                // init the padding value
                paddingBoxInput.value = '';
                
                // function that adjusts the view box and background to add padding to the image
                function setImagePadding(val,location){
                    // image w and h vars
                    let imageW;
                    let imageH;


                    // switch on the location of the padding
                    switch(location){
                        // if bottom padding
                        case 'bottom':
                            // get the new image height for the box and background
                            imageH = <%=h%> + val; 
                            // set the viewbox values to how on the bottom of the image
                            svgDOM.setAttribute("viewBox", "0 0 <%=w%> " + imageH);

                            // set background x,y to 0 to show at the bottom of the image
                            bg.setAttribute("x",0);
                            bg.setAttribute("y",0);

                            // adjust the height and set the width to what it should be
                            bg.setAttribute("height", imageH);
                            bg.setAttribute("width",<%=w%>);
                            // same with canvas to allow exporting the padding
                            canvas.setAttribute("height", imageH);
                            canvas.setAttribute("width",<%=w%>);
                            // fix the svg to properly export all content
                            svgDOM.setAttribute("height", imageH);
                            svgDOM.setAttribute("width",<%=w%>);
                            // call makeDraggable again to reset the boundaries of the draggable elements
                            makeDraggable(svgDOM);
                            break;

                        case "top":
                            // get the new image height for the box and background
                            imageH = <%=h%> + val;
                            // set background x,y to show padding at the right spot
                            bg.setAttribute("y",val*-1);
                            bg.setAttribute("x",0);
                            // adjust the height and set the width to what it should be
                            bg.setAttribute("height",imageH);
                            bg.setAttribute("height",<%=w%>);
                            
                            // set the viewbox values 
                            svgDOM.setAttribute("viewBox", "0 " + String(val*-1) + " <%=w%> " + imageH);
                            // same with canvas to allow exporting the padding
                            canvas.setAttribute("height", imageH);
                            canvas.setAttribute("width",<%=w%>);
                            // fix the svg to properly export all content
                            svgDOM.setAttribute("height", imageH);
                            svgDOM.setAttribute("width",<%=w%>);
                            // call makeDraggable again to reset the boundaries of the draggable elements
                            makeDraggable(svgDOM);
                            break;

                        case "right":
                            // get the new image width for the box and background
                            imageW = <%=w%> + val;
                            // set background x,y to padding at the right spot
                            bg.setAttribute("y",0);
                            bg.setAttribute("x",0);
                            // adjust the height and set the width to what it should be
                            bg.setAttribute("width",imageW);
                            bg.setAttribute("height",<%=h%>);
                            
                            // set the viewbox values
                            svgDOM.setAttribute("viewBox", "0 0 "  + imageW + " <%=h%>");
                            // same with canvas to allow exporting the padding
                            canvas.setAttribute("width", imageW);
                            canvas.setAttribute("height",<%=h%>);
                            // fix the svg to properly export all content
                            svgDOM.setAttribute("width", imageW);
                            svgDOM.setAttribute("height",<%=h%>);
                            // call makeDraggable again to reset the boundaries of the draggable elements
                            makeDraggable(svgDOM);
                            break;


                        case "left":
                            // get the new image width for the box and background
                            imageW = <%=w%> + val;
                            // set background x,y to padding at the right spot
                            bg.setAttribute("y",0);
                            bg.setAttribute("x",val*-1);
                            // adjust the height and set the width to what it should be
                            bg.setAttribute("width",imageW);
                            bg.setAttribute("height",<%=h%>);
                            
                            // set the viewbox values 
                            svgDOM.setAttribute("viewBox",  String(val*-1)+ " 0 "  + imageW + " <%=h%>");
                            // same with canvas to allow exporting the padding
                            canvas.setAttribute("width", imageW);
                            canvas.setAttribute("height",<%=h%>);
                            // fix the svg to properly export all content
                            svgDOM.setAttribute("width", imageW);
                            svgDOM.setAttribute("height",<%=h%>);
                            // call makeDraggable again to reset the boundaries of the draggable elements
                            makeDraggable(svgDOM);
                            break;

                        default:
                            // get the new image width and height for the box and background
                            imageW = <%=w%>;
                            imageH = <%=h%>; 

                            // set background x,y to padding at the right spot                            
                            bg.setAttribute("x",0);
                            bg.setAttribute("y",0);
                            // adjust the height and set the width to what it should be
                            bg.setAttribute("width",imageW);
                            bg.setAttribute("height",imageH);

                            // set the viewbox values
                            svgDOM.setAttribute("viewBox", "0 0 <%=w%> <%=h%>");
                            // same with canvas to allow exporting the padding
                            canvas.setAttribute("width", <%=w%>);
                            canvas.setAttribute("height",<%=h%>);
                            // fix the svg to properly export all content
                            svgDOM.setAttribute("width", <%=w%>);
                            svgDOM.setAttribute("height",<%=h%>);
                            // call makeDraggable again to reset the boundaries of the draggable elements
                            makeDraggable(svgDOM);

                    }
                        
                    
                }

                // jquery to detect a click on the padding buttons 
                $("#bottomPaddingBtn").on('click',function(event){
                    if(!isNaN(parseInt(paddingBoxInput.value))){
                        setImagePadding(parseInt(paddingBoxInput.value),'bottom');
                    }else{
                        setImagePadding(parseInt(0),"none");   
                    }
                });

                $("#topPaddingBtn").on('click',function(event){
                    if(!isNaN(parseInt(paddingBoxInput.value))){
                        setImagePadding(parseInt(paddingBoxInput.value),'top');
                    }else{
                        setImagePadding(parseInt(0),"none");   
                    }
                });

                $("#rightPaddingBtn").on('click',function(event){
                   
                    if(!isNaN(parseInt(paddingBoxInput.value))){
                        setImagePadding(parseInt(paddingBoxInput.value),'right');
                    }else{
                        setImagePadding(parseInt(0),"none");   
                    } 
               });

               $("#leftPaddingBtn").on('click',function(event){
                   
                   if(!isNaN(parseInt(paddingBoxInput.value))){
                       setImagePadding(parseInt(paddingBoxInput.value),'left');
                   }else{
                       setImagePadding(parseInt(0),"none");   
                   } 
              });

                $("#resetPaddingBtn").on('click',function(event){
                   
                    setImagePadding(parseInt(0),"none"); 
                    paddingBoxInput.value = "";  
                    
                });
/* 
                // when the image registers a click
                $("image").on("click", function(event) {
                    event.preventDefault();
                    // capture event variables for px calculations
                    var t = event.target;
                    var x = event.pageX;
                    var y = event.pageY;
                
                    // if the target is the svg DOM then keep it the same 
                      //  otherwise set it to the parent of the current target 
                    var target = (t == svg ? svg : t.parentNode);
                    // get the converted svg coordinates
                    var svgP = svgPoint(target, x, y);
                    // convert floats to integers
                    var x = parseInt(svgP.x),
                        y = parseInt(svgP.y);
                
                    // ======== FOR TESTING=======
                    console.log("x is: " + x);
                    console.log("y is:" + y);
                    // ===========================

                    /* // if any of the flags are true
                    if(cropFlag){

                        // and if the click array is either length = 0 or the clicks are in 
                           // a proper location for cropping capture the click in the clickArray 
                        if(clickArray.length === 0){
                            captureClick(x,y);
                            // check click array
                            console.log(clickArray);
                        }else if(clickArray.length === 2){
                            
                            captureClick(x,y);
                            prepareCrop(clickArray);
                            
                            
                        }
                        
                        // Then if the click flag is true and the length of the array is 2
                        if(cropFlag && clickArray.length === 2){
                            // set the dimensions and visibilty of the outline box
                            outlineBox.style.visibility = 'visible';
                            svg.insert(outlineBox);
                            
                            outlineBox.setAttribute('x',clickArray[0]);
                            outlineBox.setAttribute('y',clickArray[1]);
                        }
                        // if the crop flag is true and the length of the click array is 4 crop the image
                        else if( cropFlag && clickArray.length === 4){
                            // activate loader gif 
                            loaderActivate();
                            // set done resizeing flag
                            doneResizing = true;
                            //get the array string for the request
                            let arrayStr = clickArray.toString();
                            // prevent defaults 
                            event.preventDefault();
                            // send ajax POST request through http
                            $.ajax({
                                type: 'POST',
                                cache: false,
                                async: true,
                                url: 'http://localhost:8080/crop?cropArray=' + arrayStr + '&currentImage=' +'<%= image %>',
                                success: function(response) { 
                                    // on success load the new html data into the page    
                                    $("html").html(response);
                                    // set the loader to invisible
                                    loadInvisible();
                                    // reset clickarray
                                    clickArray = [];
                                    // reset flag
                                    cropFlag = false;
                                },
                                error: function(xhr, status, err) {
                                    // on error log the error
                                    console.log(xhr.responseText);
                                    alert('Crop Failed');
                                    loadInvisible();
                                }
                            });
                            
                        }
                    }  
                }); // end image click
 */
                // set values for calculating outline box size 
                var mouseX,
                    mouseY,
                    startX,
                    startY;
                    
                    
                // ready the cropArray before pasing the points ion the required order
                // must be done this way because we cannot pass negative width and height values
                function prepareCrop(clickArray){
                    var startX = clickArray[0],
                        startY = clickArray[1],
                        endX = clickArray[2],
                        endY = clickArray[3];

                    if(startX > endX && startY > endY){
                        clickArray[0] = endX;
                        clickArray[1] = endY;
                        clickArray[2] = startX;
                        clickArray[3] = startY;
                    }
                    else if(startX > endX || startY > endY){
                        if(startX > endX){
                            clickArray[0] = startX - (startX - endX);
                            clickArray[2] = endX + (startX - endX);
                        }
                        else{
                            
                            clickArray[1] = startY - (startY - endY);
                            clickArray[3] = endY + (startY - endY);
                        }
                    }

                    return clickArray;
                }

               /*  // capture mouse position on image mouse over
                $('#crop').mousemove(function(event){
                    event.preventDefault();

                    // set event variables
                    var t = event.target;
                    var x = event.clientX;
                    var y = event.clientY;
                
                    // get proper svg as target
                    var target = (t == svg ? svg : t.parentNode);
                    
                    // get new svg relative point
                    var svgP = svgPoint(target, x, y);
                    // convert to int
                    mouseX = parseInt(svgP.x),
                    mouseY = parseInt(svgP.y);

                    console.log( "mouse over image: " + mouseX +': ' + mouseY);
                    
                    // only adjust the box if currently croppping
                    if(!doneResizing && clickArray.length > 1){
                        
                        adjustBox();
                    }
                }); */


                 
                $('#svgWrapper').on("click", function(event){
                    
                    // set event variables
                    var t = event.target;
                    var x = event.clientX;
                    var y = event.clientY;
                    // TODO: figure our how to buffer the Y portion
                    var bufferY = parseInt(Number(<%=h%>) * .09);
                    // get proper svg as target
                    var target = (t == svg ? svg : t.parentNode);
                    
                    // get new svg relative point
                    var svgP = svgPoint(target, x, y);
                    // convert to int
                    mouseX = parseInt(svgP.x),
                    mouseY = parseInt(svgP.y);
                    
                    console.log('MOUSE CLICK ON SVG OUTTER BOX: '+ mouseX + ' '+ mouseY);

                   
                 /*   COMMENTING OUT FOR NOW
                     if(cropFlag){
                        // clicking close to the 0,0
                        if(mouseX < 0 && mouseY < bufferY){
                            captureClick(0,0);
                        }
                        // if the click is close to max corner(bottom right)
                        else if(mouseY > Number(<%=h%>) - bufferY && mouseX > Number(<%=w%>)){
                            captureClick(<%=w%>,<%=h%>);
                        }
                        // if the click is close to the top right 
                        else if(mouseX > Number(<%=w%>) && mouseY < bufferY){
                            captureClick(<%=w%>,0);
                        }
                        // if the click is close to bottom left corner
                        else if(mouseX < 0 && mouseY > Number(<%=h%>) - bufferY){
                            captureClick(0,<%=h%>);
                        }
                        // for left side
                        else if(mouseX < 0 && mouseY < Number(<%=h%>) - bufferY){
                            captureClick(0,mouseY);
                        }
                        // for right side
                        else if(mouseX > Number(<%=w%>) && mouseY < Number(<%=h%>) - bufferY && mouseY > bufferY){
                            captureClick(<%=w%>,mouseY);
                        }

                        if(!doneResizing){
                                console.log(clickArray);
                            outlineBox.style.visibility = 'visible';
                            svg.appendChild(outlineBox);
                            outlineBox.setAttribute('x',clickArray[0]);
                            outlineBox.setAttribute('y',clickArray[1]);
                        }

                        if(clickArray.length === 4){
                            // and if the points arent stacked
                            if((clickArray[0] === clickArray[2] && clickArray[0] !== 0) || clickArray[1] === clickArray[3]){
                                clickArray = [];
                                alert('Cannot be cropped in this manner');
                                cropFlag = false;
                                document.getElementById('cropFlag').innerHTML = "Crop Image";
                            
                            }
                            else{
                                prepareCrop(clickArray);
                                // activate loader gif 
                                loaderActivate();
                                // set done resizeing flag
                                doneResizing = true;
                                //get the array string for the request
                                let arrayStr = clickArray.toString();
                                // prevent defaults 
                                event.preventDefault();
                                // send ajax POST request through http
                                $.ajax({
                                    type: 'POST',
                                    cache: false,
                                    async: true,
                                    url: 'http://localhost:8080/crop?cropArray=' + arrayStr + '&currentImage=' +'<%= image %>',
                                    success: function(response) { 
                                        // on success load the new html data into the page    
                                        $("html").html(response);
                                        // set the loader to invisible
                                        loadInvisible();
                                        // reset clickarray
                                        clickArray = [];
                                        // reset flag
                                        cropFlag = false;
                                    },
                                    error: function(xhr, status, err) {
                                        // on error log the error
                                        console.log(xhr.responseText);
                                        alert('Crop Failed');
                                        loadInvisible();
                                    }
                                });
                            }
                        } 
                        
                        
                    }
                     */
                });


 /*
                 $('#svgWrapper').mousemove(function(event){
                    

                        // set event variables
                        var t = event.target;
                        var x = event.clientX;
                        var y = event.clientY;
                        // TODO: figure our how to buffer the Y portion
                        var bufferY = 50;
                        // get proper svg as target
                        var target = (t == svg ? svg : t.parentNode);
                        
                        
                        // get new svg relative point
                        var svgP = svgPoint(target, x, y);
                        // convert to int
                        mouseX = parseInt(svgP.x),
                        mouseY = parseInt(svgP.y);

                        console.log('MOUSE MOVING OVER SVG BOX: ' + mouseX + ': ' + mouseY);


                    if(cropFlag && !doneResizing){


                        // clicking close to the 0,0
                        if(mouseX < 0 && mouseY < bufferY){
                            mouseX = 0;
                            mouseY = 0;
                        }
                        // if the click is close to max corner(bottom right)
                        else if(mouseY > Number(<%=h%>) - bufferY && mouseX > Number(<%=w%>)){
                            mouseX = <%=w%>;
                            mouseY = <%=h%>;
                        }
                        // if the click is close to the top right 
                        else if(mouseX > Number(<%=w%>) && mouseY < bufferY){
                            mouseX = <%=w%>;
                            mouseY = 0;
                        }
                        // if the click is close to bottom left corner
                        else if(mouseX < 0 && mouseY > Number(<%=h%>) - bufferY){
                            mouseX = 0;
                            mouseY = <%=h%>;
                        }
                        // for left side
                        else if(mouseX < 0 && mouseY < Number(<%=h%>) - bufferY){
                            mouseX = 0;
                            
                        }
                        // for right side
                        else if(mouseX > Number(<%=w%>) && mouseY < Number(<%=h%>) - bufferY && mouseY > bufferY){
                            mouseX = <%=w%>;
                        }
                        adjustBox();
                    }
                }); */
            /*
                // function to change the outline box dimensions to the calulated size
                function adjustBox(){

                    // get start points of the crop
                    startX = clickArray[0];
                    startY = clickArray[1];

                    // convert number and do the math
                    let w = Number(mouseX) - startX;
                    let h = Number(mouseY) - startY;

                    
                    // reset the outline box if the values are not NaN
                    if(w !== NaN && h !== NaN){
                        if(w < 0 && h < 0){
                            h = Math.abs(h);
                            w = Math.abs(w);

                            outlineBox.setAttribute('x' , startX  - w);
                            outlineBox.setAttribute('y' , startY - h);
                            outlineBox.setAttribute('width' , w);
                            outlineBox.setAttribute('height' , h);
                        }else if(w < 0 || h < 0){
                            if(w<0){
                                w = Math.abs(w);

                                outlineBox.setAttribute('x' , startX  - w);
                                outlineBox.setAttribute('y' , startY);
                                
                            }else{
                                h = Math.abs(h);
                                outlineBox.setAttribute('x' , startX);
                                outlineBox.setAttribute('y' , startY - h);
                            }
                            outlineBox.setAttribute('width' , w);
                            outlineBox.setAttribute('height' , h);
                        }else{
                            outlineBox.setAttribute('width' , w);
                            outlineBox.setAttribute('height' , h);
                        }
                        
                    }
                } */

                // when north button is clicked
                $('#northIconFlag').on('mousedown',function(){
                    // change north flag
                    northFlag = !northFlag;
                    
                    // if north flag is placed currently remove it
                    if(northIconPlaced){
                        northIconPlaced = !northIconPlaced;
                        northImage.remove();
                        northImage.style.visibility = 'hidden';
                        document.getElementById('northIconFlag').setAttribute('class',"btn btn-primary btn-lg button");
                        northImage.setAttribute("transform","translate(0,0) scale(.121952)");
                        northFlag = !northFlag;
                    }
                    
                    // otherwise set the other flags to false and adjust their html
                    if(northFlag){
                        if(!sunIconPlaced){
                            sunFlag = false;
                            document.getElementById('sunIconFlag').innerHTML = "Add Sun Icon";
                        }

                        if(!eyeIconPlaced){
                            eyeFlag = false;
                            document.getElementById('eyeFlag').innerHTML = "Add Observer Icon";
                        }

                        /* cropFlag = false;
                        document.getElementById('cropFlag').innerHTML = "Crop Image"; */
                        outlineBox.remove();
                        outlineBox.style.visibility = 'hidden';
                        
                        svg.appendChild(northImage);
                        northImage.style.visibility = 'visible';
                        northIconPlaced = !northIconPlaced;
                        northFlag = false;
                        document.getElementById('northIconFlag').setAttribute('class',"btn btn-secondary btn-lg button");
                    }
                    
                    clickArray = [];
                }); 


                // use same logic for other button
                $('#eyeFlag').click(function(){
                    eyeFlag = !eyeFlag;

                    if(eyeIconPlaced){
                        eyeIconPlaced = !eyeIconPlaced;
                        eyeImage.remove();
                        eyeImage.style.visibility = 'hidden';
                        eyeFlag = !eyeFlag;
                        document.getElementById('eyeFlag').setAttribute('class',"btn btn-primary btn-lg button");
                        eyeImage.setAttribute("transform","translate(0,100) scale(.15625)");
                    }
                    
                    if(eyeFlag){
                        
                        cropFlag = false;
                       /*  document.getElementById('cropFlag').innerHTML = "Crop Image"; */
                        outlineBox.remove();
                        outlineBox.style.visibility = 'hidden';
                        
                        svg.appendChild(eyeImage);
                        eyeImage.style.visibility = 'visible'
                        document.getElementById('eyeFlag').setAttribute('class',"btn btn-secondary btn-lg button");
                        eyeFlag = false;
                        eyeIconPlaced = true;
                    }
                    
                });

                // use same logic for other button
                $('#sunIconFlag').click(function(){
                    sunFlag = !sunFlag;

                    if(sunIconPlaced){
                        sunIconPlaced = !sunIconPlaced;
                        sunImage.style.visibility = 'hidden';
                        sunImage.remove();
                        document.getElementById('sunIconFlag').setAttribute('class',"btn btn-primary btn-lg button");
                        sunFlag = false;
                        sunImage.setAttribute("transform","translate(0,150) scale(.15625)");
                            
                    }
                    
                    if(sunFlag){
                        
                        cropFlag = false;
                        outlineBox.style.visibility = 'hidden';
                        
                       /*  document.getElementById('cropFlag').innerHTML = "Crop Image"; */
                        sunImage.style.visibility = 'visible';
                        svg.appendChild(sunImage);
                        sunFlag = false;
                        sunIconPlaced = true;
                        document.getElementById('sunIconFlag').setAttribute('class',"btn btn-secondary btn-lg button");
                        
                    }
                    
                    clickArray = [];
                });


/* 
                // use same logic for other button
                $("#cropFlag").click(function(){
                    cropFlag = !cropFlag;

                    if(cropFlag){
                        if(!northIconPlaced){
                            northFlag = false
                            document.getElementById('northIconFlag').innerHTML = "Add North Arrow";
                        }
                        if(!sunIconPlaced){
                            sunFlag = false;
                            document.getElementById('sunIconFlag').innerHTML = "Add Sun Icon";
                        }
                        if(eyeFlag && !eyeIconPlaced){
                            eyeFlag = false;
                            document.getElementById('eyeFlag').innerHTML = "Add Observer Icon";
                        }

                        document.getElementById('cropFlag').innerHTML = "Cancel?";
                        
                    }else{
                        clickArray = [];
                        document.getElementById('cropFlag').innerHTML = "Crop Image";
                        outlineBox.style.visibility = 'hidden';
                    }
                    
                }); */




/* 
                // button to undo the cropped image
                $("#backBtn").on('click',function(event){
                    event.preventDefault();

                    var currentImg = '<%= image %>';

                    console.log(currentImg);

                    // if the image has been cropped then get the previous image
                    if(currentImg.indexOf('_crop.png') > -1){
                        // ajax request for the data sending the current image link
                        $.ajax({
                            type: 'GET',
                            
                            cache: false,
                            url: 'http://localhost:8080/crop?currentImage=' +'<%= image %>',
                            success: function(response) {
                                $("html").html(response);
                            
                                
                            },
                            error: function(xhr, status, err) {
                                console.log(xhr.responseText);
                                loadInvisible();
                                
                            }
                        });
                    }else{
                        // if the current image is the base image then alert the user
                        loadInvisible();
                        alert('Base Image:\nCannot Be Undone');
                    }

                    
                }); */
            
            }); // end doc.ready
            
            // function to push the x,y coordinates into the clickArray
            function captureClick(x,y){
                clickArray.push(x);
                clickArray.push(y);
            }

            
            // Export Section

            // download works well for pngs
            function triggerDownload (imgURI,filename) {
                var event = new MouseEvent('click', {
                    view: window,
                    bubbles: false,
                    cancelable: true
                });
                var a = document.createElement('a');
                a.setAttribute('download', filename);
                a.setAttribute('href', imgURI);
                a.setAttribute('target', '_blank');

                a.dispatchEvent(event);
            }

            
            // when the export is clicked
            exportBtn.addEventListener('click', function () {
                
                // get the svg element and the canvas information
                canvas = document.getElementById('canvas');
                var ctx = canvas.getContext('2d');

                var data = (new XMLSerializer()).serializeToString(svg);
                var DOMURL = window.URL || window.webkitURL || window;

                // creates new image from svg inline elements excludiong the actual image
                var img = new Image();
                var svgBlob = new Blob([data], {type: 'image/svg+xml;charset=utf-8'});
                var url = DOMURL.createObjectURL(svgBlob);

                
                img.onload = function(){
                    // draw the svg image onto the canvas
                    ctx.drawImage(img,0,0);
                    
                    // if the filename a false value
                    if(!filename){
                        // read in a filename with prompt
                        var filename = prompt("Save File as png svg or jpeg","");
                    }

                    // if the filename is one of the accepted filenames and it isnt null              
                    if( filename !== null && /^.*\.(png|PNG|JPEG|jpeg|JPG|jpg|SVG|svg)$/gm.test(filename)){
                        var fileExt = filename.split(".")[filename.split(".").length - 1];

                        // if the fileExt is NOT svg
                        if(fileExt !== 'svg'){
                            try{
                                if(fileExt === 'jpg'){
                                    // export an image of the extension type
                                    var imgURI = canvas
                                    .toDataURL('image/jpeg', 1.0)
                                    .replace('image/jpeg', 'image/octet-stream');
                                }
                                else{
                                    // export an image of the extension type
                                    var imgURI = canvas
                                    .toDataURL('image/'+fileExt, 1.0)
                                    .replace('image/'+fileExt, 'image/octet-stream');
                                }
                                
                                // start the download
                                triggerDownload(imgURI,filename);            
                            }catch(err){
                                alert('Image is too large to save from browser');
                            }
                        }else{
                            // fileExt === 'svg'
                            try{
                                // trigger the download with the svg url instead of converting to image
                                triggerDownload(url,filename);       
                            }catch(err){
                                alert('Image is too large to save from browser');
                            }

                        }
                    }
                    // must enter an accepted fileExt
                    else if(filename !== null){
                       exportBtn.click();
                    }
                    // revoke the url
                    DOMURL.revokeObjectURL(url);

                    // Note:
                    //     if the user hits cancel the filename will be null, we ignore this case
                };
                // set the img src to the url
                try{
                    img.src = url;
                }catch(err){
                    console.log('source could not be located');
                }
            });
        </script>

        <!-- Legend Section-->
        <br/>
        <div class="position-relative text-center" style="margin-left:auto; margin-right:auto; display: none;">
            <h2 style="padding-top:1%;padding-bottom:1%; margin-bottom: 0%;">Image Legend</h2>
            <table class="float-center text-center" style="margin-left:auto; margin-right:auto; margin-top: 0px;">
                <tr>
                    <td>
                        <svg id="legend-image" width="450" height="200">
                            <rect width="100%" height="100%" rx="10" ry="10" style="fill:rgb(233, 236, 239);">
                            </rect>
                            <foreignObject x="10" y="10" width="100%" height="100%">
                                <table class="float-center" id="legend-table">
                                    <tr id="north">
                                        <th>North:</th>
                                        <th><img id="northImg" src="images/north.png" width="25" preserveAspectratio="xMaxYMid meet" height="25"><img/></th>
                                        <th id="northDeg">0 degrees</th>
                                    </tr>
                                    <tr id="sun-az">
                                        <th>Sun Azimuthal Direction:</th>
                                        <th><img id="sunImg" src="images/sun_symbol.png" width="25" height="25"></img></th>
                                        <th id="sunDeg">0 degrees</th>
                                    </tr>
                                    <tr id="obs-az">
                                        <th>Observer Azimuthal Direction:</th>
                                        <th><img id="observerImg" src="images/eye_symbol.png" width="25" height="25"></img></th>
                                        <th id="obsDeg">0 degrees</th>
                                    </tr>
                                    <tr id="image-scalebar" style="overflow:hidden;">
                                        <th>Scalebar:</th>
                                        <th><img src="images/arrow.png" width="25" height="25"></img></th>
                                        <th id="scaleDeg">0 degrees</th>
                                    </tr>   
                                </table>
                            </foreignObject>
                            <line id="observerArrow" x1="0" y1="0" x2="50" y2="0" style="stroke:rgb(255,0,0);stroke-width:2; display:none;"/>
                            <line id="sunArrow" x1="0" y1="0" x2="50" y2="0" style="stroke:rgb(255,0,0);stroke-width:2; display:none;"/>
                        </svg>
                    </td>
                    <td valign="top">
                        <div class="float-center" style="align-content: center; width: 300px; height: auto; margin: auto;">
                            <div id="hide-legend" class="float-center" style="text-align: left;">
                                <table style="text-align:left;">
                                    <tr><h4>Hide Legend Elements</h4></tr>
                                    <tr><input type="checkbox" id="north-radio" name="leg" checked>North Arrow</input><br/></tr>
                                    <tr><input type="checkbox" id="sun-radio" name="leg" checked>Sun Azimuthal Direction</input><br/></tr>
                                    <tr><input type="checkbox" id="obs-radio" name="leg" checked>Observer Azimuthal Direction</input><br/></tr>
                                    <tr><input type="checkbox" id="scalebar-radio" name="leg" checked>Scalebar</input><br/></tr>
                                </table>
                            </div>
                        </div>
                    </td>
                </tr>
            </table>
        </div>
        <br/>
        <br/>
        <br/>
         
        <!-- Exporting The Legend-->
        <div id="legend-export-div" style="margin-left:35%;">
        </div>
                                                                    
        <script>
            function exportLegend(){
                var div = document.getElementById("legend-export-div");
                html2canvas(document.querySelector("#legend-table")).then(function(canvas) {
                    document.getElementById("legend-export-div").append(canvas);        
                    //document.body.appendChild(canvas);
                });
            }
        </script>
        <script>
            function hideNorth(){
                document.getElementById("north").style.display = "none";
                //console.log("Hiding North");
            }
            function showNorth(){
                document.getElementById("north").style.display = "table-row";
                //console.log("Showing North");
            }
            function hideSun(){
                document.getElementById("sun-az").style.display = "none";
            }
            function showSun(){
                document.getElementById("sun-az").style.display = "table-row";
            }
            function hideObs(){
                document.getElementById("obs-az").style.display = "none";
            }
            function showObs(){
                document.getElementById("obs-az").style.display = "table-row";
            }
            function hideScale(){
                document.getElementById("image-scalebar").style.display = "none";
                //console.log("Showinfgejnhfkjshdf");
            }
            function showScale(){
                document.getElementById("image-scalebar").style.display = "table-row";
                //console.log("actually show");
            }

            // function to hide the elements in the legend area
            function showHide(){
                var northRadio = document.getElementById("north-radio").checked;
                var sunRadio = document.getElementById("sun-radio").checked;
                var obsRadio = document.getElementById("obs-radio").checked;
                var scalebarRadio = document.getElementById("scalebar-radio").checked;
                if(!northRadio){
                    hideNorth();
                }else{
                    showNorth();
                }
                if(!sunRadio){
                    hideSun();
                }else{
                    showSun();
                }
                if(!obsRadio){
                    hideObs();
                }else{
                    showObs();
                }
                if(!scalebarRadio){
                    hideScale();
                }else{
                    showScale();
                }
            }
            setInterval(showHide, 1000);
        </script>

        <script>
            // Gets Important Metadata from the "metadata-text" div
            function getMetadata(){
                // get value string from hidden DOM element
                var metadata = document.getElementById("metadata-text").innerHTML;
                // parse back into JSON
                var metadataString = JSON.parse(metadata);
                
                // Important Metadata Values
                var northDegree = metadataString['NorthAzimuth'];
                var sunDegree = metadataString['SubSolarAzimuth'];
                var observerDegree = metadataString['SubSpacecraftGroundAzimuth'];
                var scale = metadataString['SampleResolution'];

                // ======= Hard Coding North Arrow For Testing =========
                northDegree = 90;
                // ==================================================

                // TODO: generate an arrow in the proper direction in relation to the degree of the sun and eye angles
                if(northDegree == "None"){
                    document.getElementById("north-radio").checked = false;
                }else{
                    setLegendAngle("northImg", "northDeg", northDegree);
                }

                if(sunDegree == "None"){
                    document.getElementById("sun-radio").checked = false;
                }

                if(observerDegree == "None"){
                    document.getElementById("obs-radio").checked = false;
                }

                // scale will be generated using the SampleResolution and the size of the image (meters/px)
                if(scale == "None"){
                    document.getElementById("scalebar-radio").checked = false;
                }
            }

            // set the arrow directions and recieve the data
            getMetadata();
            
            // Set Legend North Angle Angle
            function setLegendAngle(img, degree, value){
                // get the image element and the element to display the angle degree
                let image = document.getElementById(String(img));
                let deg = document.getElementById(String(degree));
                // rotate the value using css transform
                let rotateVal = String("transform: rotate(" + String(value) + "deg);");
                // transform about the origin
                image.setAttribute("transform-origin", "50%; 50%;");
                // change the html angle display
                deg.innerHTML = String(value) + "degrees";

                // set the new style for the image
                image.setAttribute("style", rotateVal);
            }

            // Generate Arrow Legend Icons
            function setLegendArrow(img, arrow, deg, value){
                var image = document.getElementById(String(img));
                //var arrow = document.getElementById();
            }

        /*  //========== This Function is for testing the Rotation Orgin Point ===============
            i = 0;
            setInterval(function(){
                i += 1;
                setLegendAngle("northImg", "northDeg", i);
            }, 1000);
            //============================================================================ */
        </script>
        
    </body>
</html>

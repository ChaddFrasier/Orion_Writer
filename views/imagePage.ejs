<html>
    <head>
        <!-- Required meta tags -->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=yes">

        <link rel="stylesheet", href="css/pips.css" type="text/css">

        <!-- Bootstrap CSS -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
            integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

        <title>Image Editor</title>

        <script src="http://ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js"></script>
    </head>

    <script type="text/javascript">
        // function to create a draggable field from svg element
        function makeDraggable(event) {
        
            // get svg element
            var svg = event;
        
            // adds event functions to the whole svg element
            svg.addEventListener('mousedown', startDrag);
            svg.addEventListener('mousemove', drag);
            svg.addEventListener('mouseup', endDrag);
            svg.addEventListener('mouseleave', endDrag);
            
            // decrale all global function variables for dragging
            var selectedElement, offset, transform,
                bbox, minX, maxX, minY, maxY, confined,elementOver;
            // & for resizing
            var resizing = false,
                dragging = false,
                currentScale,
                transformString,
                startH,
                startW,
                minNorth = .1219513,
                maxNorth = 1.219513,
                minSun = .15625,
                maxSun = 1.5625,
                minEye = .52,
                maxEye = 5.2,
                maxText = textSize*10,
                minText = textSize,
                iconMin,
                outlineMin = .125,
                scale;
            
                
            // sets boundries for draggable objects when confined based on the view box
            // minX = x of viewbox
            var boundaryX1 = Number(svg.getAttribute('viewBox').split(" ")[0]);
            // maxX = the width of the viewbox - the absolute value of the x value
            var boundaryX2 = Number(svg.getAttribute('viewBox').split(" ")[2]) - Math.abs(Number(svg.getAttribute('viewBox').split(" ")[0]));
            // minY = y of the viewBox
            var boundaryY1 = Number(svg.getAttribute('viewBox').split(" ")[1]);
            // maxY = the height of the viewbox - the absolute value of the  y of the view box
            var boundaryY2 = Number(svg.getAttribute('viewBox').split(" ")[3]) - Math.abs(Number(svg.getAttribute('viewBox').split(" ")[1]));


            // get the mouse position relative to the svg screen matrix
            // math functions were found on a blog post
            function getMousePosition(event) {
                var CTM = svg.getScreenCTM();
                
                return {
                    x: (event.clientX - CTM.e) / CTM.a,
                    y: (event.clientY - CTM.f) / CTM.d
                };
            }

            // start the drag on mousedown
            function startDrag(event){
                // get the mouseX and mouseY on the client
                mX = event.clientX, mY = event.clientY;
                // prevent all other mousedown events
                event.preventDefault();
                // find what element the event is on
                elementOver = document.elementFromPoint(mX,mY);
                // get the element that needs to be dragged or scaled
                selectedElement = event.target.parentNode;

                // if the event.target.parentNode is the svg element set it back to the target
                if(selectedElement === svg){
                    selectedElement = event.target;
                }

                // grab the limits scale value for whichever icon is selected
                // functions find min if passed true and find max if passed false
                if(selectedElement){
                    iconMin = findLimit(selectedElement,true);
                    iconMax = findLimit(selectedElement, false);
                }

                // get the bounding box of the group element
                try{
                    bbox = selectedElement.getBBox();
                }catch(err){
                    return;
                }
                // Make sure the first transform on the element is a translate transform
                var transforms = selectedElement.transform.baseVal;

                // if the element that the mousedown happened over is a resize block and the function is not currently resizing,
                // start resize logic
                if(elementOver.classList.contains('resize') && !resizing){
                    // set resizing flag
                    resizing = true;
                
                    // get scale data
                    scale = transforms.getItem(transforms.length -1);

                    // get the coordinates where the click happend inside the svg box
                    offset = getMousePosition(event);

                    // get the transform string so we can change it later strip the scale part off the end because we are resizing
                    transformString = selectedElement.getAttribute("transform").split("scale(")[0];
                    
                    // extract the scale value as a number
                    currentScale = scale.matrix.a;

                    // get translate data
                    transform = transforms.getItem(0);

                }
                // if the event click happened on a draggable element start drag logic
                else if (selectedElement.classList.contains('draggable')) {
                    // set dragging flag
                    dragging = true;
                    // get the offset value for the translation
                    offset = getMousePosition(event);
                    // get scale data
                    scale = transforms.getItem(transforms.length -1);

                    // make sure that the first element of the tranform object is the translate and create one if it isnt there
                    if (transforms.length === 0 || transforms.getItem(0).type !== SVGTransform.SVG_TRANSFORM_TRANSLATE) {
                    // sets current transform position to 0,0 to make moving item easier
                    var translate = svg.createSVGTransform();
                    translate.setTranslate(0, 0);
                    selectedElement.transform.baseVal.insertItemBefore(translate, 0);
                    }

                    // Get initial translation in relation to the current mouse position (offset) and the current translation
                    transform = transforms.getItem(0);

                    // calculate the transform location in relation to the svg element
                    offset.x -= transform.matrix.e;
                    offset.y -= transform.matrix.f;

                    // is the selected item confined?
                    confined = selectedElement.classList.contains('confine');

                    // if true
                    if (confined) {
                        let rotateVal = transforms.getItem(1).angle;
                        if(rotateVal > 360){rotateVal-= 360;}

                        // get the current scale of the icon
                        let scaleFactor = scale.matrix.a;
                        bbox = selectedElement.getBBox();

                        // if no rotate has occured
                        if(rotateVal ===0 || rotateVal === 360 ){
                            // set the new boundry values based on the view box and the width/height of the icons
                            // dim * scale = dim of icon
                            minX = boundaryX1 - bbox.x;
                            maxX = boundaryX2 - bbox.x - bbox.width * scaleFactor;
                            minY = boundaryY1 - bbox.y;
                            maxY = boundaryY2 - bbox.y - bbox.height * scaleFactor;
                        }
                        else{ // rotate has been applied
                            // calculate the degree of the rotation in radians
                            var trigInput = rotateVal * Math.PI/180;
                            var trigInput2 = (rotateVal-90) * Math.PI/180;
                            var trigInput3 = (rotateVal-180) * Math.PI/180;
                            var trigInput4 = (rotateVal-270) * Math.PI/180;

                            // check for easy angle calculations, this save processing time if the value is a 45 45 90 triangle
                            // 30 60 90 triangle, or a interval of 90 degrees
                            if(rotateVal === 180){
                                // set the new boundry values based on the view box and the width/height of the icons
                                // dim * scale = dim of icon
                                minX = boundaryX1 - bbox.x+ bbox.width * scaleFactor;
                                maxX = boundaryX2 - bbox.x;
                                minY = boundaryY1 - bbox.y + bbox.height * scaleFactor;
                                maxY = boundaryY2 - bbox.y;
                            }else if(rotateVal === 90){
                                // set the new boundry values based on the view box and the width/height of the icons
                                // dim * scale = dim of icon
                                minX = boundaryX1 - bbox.x + bbox.height * scaleFactor;
                                maxX = boundaryX2 - bbox.x;
                                minY = boundaryY1 - bbox.y;
                                maxY = boundaryY2 - bbox.y - bbox.width * scaleFactor;
                            }else if(rotateVal === 270){
                                // set the new boundry values based on the view box and the width/height of the icons
                                // dim * scale = dim of icon
                                minX = boundaryX1 - bbox.x;
                                maxX = boundaryX2 - bbox.x - bbox.height * scaleFactor;
                                minY = boundaryY1 - bbox.y + bbox.width * scaleFactor;
                                maxY = boundaryY2 - bbox.y;
                            }
                            else if(rotateVal === 45){
                                // set the new boundry values based on the view box and the width/height of the icons
                                // dim * scale = dim of icon
                                minX = boundaryX1 - bbox.x + (bbox.height * scaleFactor/Math.sqrt(2));
                                maxX = boundaryX2 - bbox.x - (bbox.width * scaleFactor)/Math.sqrt(2);
                                minY = boundaryY1 - bbox.y;
                                maxY = boundaryY2 - bbox.y - (bbox.width * scaleFactor)/Math.sqrt(2) - (bbox.height * scaleFactor)/Math.sqrt(2);
                            }
                            else if(rotateVal === 135){
                                // set the new boundry values based on the view box and the width/height of the icons
                                // dim * scale = dim of icon
                                minX = boundaryX1 - bbox.x + (bbox.height * scaleFactor/Math.sqrt(2)+ (bbox.width * scaleFactor/Math.sqrt(2)));
                                maxX = boundaryX2 - bbox.x;
                                minY = boundaryY1 - bbox.y + (bbox.height * scaleFactor)/Math.sqrt(2);
                                maxY = boundaryY2 - bbox.y - (bbox.width * scaleFactor)/Math.sqrt(2);                            
                            }
                            else if(rotateVal === 225){
                                // set the new boundry values based on the view box and the width/height of the icons
                                // dim * scale = dim of icon
                                minX = boundaryX1 - bbox.x + (bbox.width * scaleFactor/Math.sqrt(2));
                                maxX = boundaryX2 - bbox.x - bbox.height * scaleFactor/Math.sqrt(2);
                                minY = boundaryY1 - bbox.y + (bbox.height * scaleFactor)/Math.sqrt(2) + (bbox.width * scaleFactor)/Math.sqrt(2);
                                maxY = boundaryY2 - bbox.y;
                            }
                            else if(rotateVal === 315){
                                // set the new boundry values based on the view box and the width/height of the icons
                                // dim * scale = dim of icon
                                minX = boundaryX1 - bbox.x;
                                maxX = boundaryX2 - bbox.x  - bbox.height * scaleFactor/Math.sqrt(2) - bbox.width * scaleFactor/Math.sqrt(2);
                                minY = boundaryY1 - bbox.y  + (bbox.width * scaleFactor)/Math.sqrt(2);
                                maxY = boundaryY2 - bbox.y - (bbox.height * scaleFactor)/Math.sqrt(2);
                            }
                            // end of easy calculations
                            // if less than 90 calculate using trig using the first trig radian value
                            // the triangles caculated are based on the top left of the original icon so we need 4 different checks
                            else if(rotateVal < 90){
                                minX = boundaryX1 - bbox.x  + Math.sin(trigInput)*(bbox.height*scaleFactor);
                                maxX = boundaryX2 - bbox.x - Math.cos(trigInput)*(bbox.width*scaleFactor);
                                minY = boundaryY1 - bbox.y;
                                maxY = boundaryY2 - bbox.y - (Math.cos(trigInput)*(bbox.height*scaleFactor) + Math.sin(trigInput)*(bbox.width*scaleFactor));
                            }
                            else if(rotateVal < 180){
                                // calculate with 2nd radian value
                                minX = boundaryX1 - bbox.x + Math.sin(trigInput2) * (bbox.width*scaleFactor) + Math.cos(trigInput2)*(bbox.height*scaleFactor);;
                                maxX = boundaryX2 - bbox.x;
                                minY = boundaryY1 - bbox.y + Math.sin(trigInput2)*(bbox.height*scaleFactor);
                                maxY = boundaryY2 - bbox.y - (Math.cos(trigInput2)*(bbox.width*scaleFactor));
                            }
                            else if(rotateVal < 270){
                                //calculate with 3rd radian value
                                minX = boundaryX1 - bbox.x + Math.cos(trigInput3) * (bbox.width*scaleFactor);
                                maxX = boundaryX2 - bbox.x - Math.sin(trigInput3) * (bbox.height*scaleFactor);
                                minY = boundaryY1 - bbox.y + Math.cos(trigInput3)*(bbox.height*scaleFactor) + Math.sin(trigInput3)*(bbox.width*scaleFactor);
                                maxY = boundaryY2 - bbox.y;
                            }
                            else if(rotateVal < 360){
                                // calculate with 4th radian value     
                                minX = boundaryX1 - bbox.x;
                                maxX = boundaryX2 - bbox.x - Math.cos(trigInput4) * (bbox.height*scaleFactor) - Math.sin(trigInput4) * (bbox.width*scaleFactor);
                                minY = boundaryY1 - bbox.y + Math.cos(trigInput4)*(bbox.width*scaleFactor);
                                maxY = boundaryY2 - bbox.y - Math.sin(trigInput4)*(bbox.height*scaleFactor);    
                            }
                        }
                        console.log("BOUNDING DIMENSIONS ARE FROM: x" + minX + " to " + maxX);
                        console.log("AND Y: " + minY + " to " + maxY);
                    }
                }
            }

            // set flags for rescale
            var bottomL = false,
                bottomR = false,
                topR = false,
                topL = false,
                bottom=false;
            

            // move the icon around using translate or scale it by detecting what the mouse was over on the click
            function drag(event) {
                // get the mouse x and y based on client
                mX = event.clientX, mY = event.clientY;

                // set the factor at which the resize happens
                let growingFactor = .02;

                // reset growing factor if needed
                if( elementOver && elementOver.parentElement && elementOver.parentElement.classList.contains("textbox")){
                    growingFactor *= 10;
                }else if(selectedElement && selectedElement.id.indexOf("eye") > -1){
                    growingFactor *=2.5;
                }
                
                // if the selectedElement is non false then check if its an outline
                if(selectedElement){
                    var isOutline = selectedElement.classList.contains("outline");
                }
                
                // prevent all other mousemove events
                event.preventDefault();
                
                // if the selectedElement is not null and resizing is true and dragging is false
                if(selectedElement && resizing && !dragging){
            
                    // get new mouse position in svg space
                    var coord = getMousePosition(event);

                    // calculate icon size using bbox height and width times the scale 
                    startH = bbox.height * currentScale;
                    startW = bbox.width * currentScale;

                    // first make sure there are no other flags active and
                    // either the top right element is moused over or the top right is being moved
                    if((!topL && !bottomL && !bottomR) && (elementOver.classList.contains('top-right') || topR)){
                        //set the flag just incase it isn't
                        topR = true;
                        // if the new x is less  & the new y is greater than the old position then shrink
                        if(coord.x < offset.x && coord.y > offset.y){
                            // decrement by the growing factor
                            currentScale -= growingFactor;
                            // check for the min
                            if(currentScale < iconMin){currentScale = iconMin;}

                            // translate the icon 0 in the x direction and by the difference in the positive y direction
                            dx = parseInt(transform.matrix.e);
                            dy = parseInt(transform.matrix.f + Math.abs(startH - bbox.height * currentScale)/4);
                        }
                        // if the old x is greater and the new y is smaller then we are growing
                        else if(coord.x > offset.x && coord.y < offset.y){
                            // increment by the factor
                            currentScale += growingFactor;

                            // check for max size
                            if(currentScale > iconMax){currentScale = iconMax;}
                            if(!isOutline && bbox.height * currentScale > parseInt("<%=h%>")/3){currentScale -= growingFactor}
                            
                            // translate the icon 0 in the x direction and by the difference in the negative y direction        
                            dx = parseInt(transform.matrix.e);
                            dy = parseInt(transform.matrix.f - Math.abs(startH - bbox.height * currentScale)/4);    
                        }

                        // set scale using svg data method
                        scale.setScale(currentScale,currentScale);
                        // if parse it returns a true value for both
                        /* if(dx && dy){
                            // set the new translate
                            transform.setTranslate(dx,dy);
                        } */
                        // set the new mouse position as the old so we can scale up and down
                        offset = coord;
                    }
                    // using the same logic for other corners of the scale
                    else if((!topR && !bottomL && !bottomR) && (elementOver.classList.contains('top-left') || topL)){
                        topL = true;
                        // if new x is greater than the old & the new y is greater than the old
                        // shrink the scale
                        if(coord.x > offset.x && coord.y > offset.y){
                            currentScale -= growingFactor;
                            // check for min
                            if(currentScale < iconMin){currentScale = iconMin;}

                            // transform the icon by the positive difference in the sizes                        
                            dx = parseInt(transform.matrix.e + Math.abs(startW - bbox.width * currentScale)/4);
                            dy = parseInt(transform.matrix.f + Math.abs(startH - bbox.height * currentScale)/4);
                        }
                        // if the new x and new y are both less than the old position
                        // grow
                        else if(coord.x < offset.x && coord.y < offset.y){
                            currentScale += growingFactor;


                            // check for max size
                            if(currentScale > iconMax){currentScale = iconMax;}
                            if(!isOutline && 
                            (bbox.height * currentScale > parseInt("<%=h%>")/3 || bbox.width * currentScale > parseInt("<%=w%>")/3))
                            {currentScale -= growingFactor}

                            // transform the icon by the negative difference in the sizes
                            dx = parseInt(transform.matrix.e - Math.abs(startW - bbox.width * currentScale)/4);
                            dy = parseInt(transform.matrix.f - Math.abs(startH - bbox.height * currentScale)/4);
                        }

                        // set scale using svg data method
                        scale.setScale(currentScale,currentScale);
                        // if parse it returns a true value for both
                        /* if(dx && dy){
                            // set the new translate
                            transform.setTranslate(dx,dy);
                        } */

                        // set new mouse position
                        offset = coord;
                    }
                    // same logic as other corners
                    else if((!bottomR && !topR && !topL) && (elementOver.classList.contains('bottom-left') || bottomL)){
                        bottomL = true;
                        // if new x is greater and new y is less
                        // shrink
                        if(coord.x > offset.x && coord.y < offset.y){
                            currentScale -= growingFactor;
                            // check for min
                            if(currentScale < iconMin){currentScale =iconMin;}
                            

                            // transform the icon by the negative difference in the sizes keep y the same
                            dx = parseInt(transform.matrix.e + Math.abs(startW - bbox.width * currentScale)/4);
                            dy = parseInt(transform.matrix.f);


                        }
                        // of the new x is less and the new y is greater
                        // grow the icon
                        else if(coord.x < offset.x && coord.y > offset.y){
                            currentScale += growingFactor;

                            // check for max size
                            if(currentScale > iconMax){currentScale = iconMax;}
                            if(!isOutline && bbox.height * currentScale > parseInt("<%=h%>")/3){currentScale -= growingFactor}
                            
                            // transform the icon by the negative difference in the sizes keep y the same
                            dx = parseInt(transform.matrix.e - Math.abs(startW - bbox.width * currentScale)/4);
                            dy = parseInt(transform.matrix.f);

                        }
                        
                        // set scale using svg data method
                        scale.setScale(currentScale,currentScale);
                        // if parse it returns a true value for both
                        /* if(dx && dy){
                            // set the new translate
                            transform.setTranslate(dx,dy);
                        } */

                        // set new mouse position
                        offset = coord;
                    }
                    // same logic as other corners 
                    else if((!topL && !topR && !bottomL) && (elementOver.classList.contains('bottom-right') || bottomR)){
                        bottomR = true;
                        // if the new x is less and the new y is also less
                        // shrink
                        if(coord.x < offset.x && coord.y < offset.y){
                            currentScale -= growingFactor;
                            // check min bound
                            if(currentScale < iconMin){currentScale = iconMin;}
                        }
                        // if the new x is greater than the old and the new y is greater
                        // grow
                        else if(coord.x > offset.x && coord.y > offset.y){
                            currentScale += growingFactor;

                            //check for max size
                            if(currentScale > iconMax){currentScale = iconMax;}
                            if(!isOutline && bbox.height * currentScale > parseInt("<%=h%>")/3){currentScale -= growingFactor}
                        }
                        // set scale using svg data method
                        scale.setScale(currentScale,currentScale);
                        // no need to translate for bottom right corner
                        // set new mouse position
                        offset = coord;
                    }

                    // same logic as other corners 
                    else if((!topL && !topR && !bottomL && !bottomR) && (elementOver.classList.contains('bottom') || bottom)){
                        bottom = true;
                        // if the new x is less and the new y is also less
                        // shrink
                        if(coord.y < offset.y){
                            currentScale -= growingFactor*10;
                            // check min bound
                            if(currentScale < iconMin){currentScale = iconMin;}
                        }
                        // if the new x is greater than the old and the new y is greater
                        // grow
                        else if(coord.y > offset.y){
                            currentScale += growingFactor*10;

                            //check for max size
                            if(currentScale > iconMax){currentScale = iconMax;}
                            if(!isOutline && bbox.height * currentScale > parseInt("<%=h%>")/3){currentScale -= growingFactor}
                        }
                        // set scale using svg data method
                        scale.setScale(currentScale,currentScale);
                        // no need to translate for bottom right corner
                        // set new mouse position
                        offset = coord;
                    }

                    // if the element is an outline then reset the stroke to the proper size
                    // removing the current scale and applying the base scale
                    if(isOutline){
                        // calculate and set the stroke-width
                        selectedElement.style.strokeWidth = (parseInt(selectedElement.getAttribute("stroke-width"))/currentScale)*.5;
                    }
                    if(isOutline || selectedElement.classList.contains("textbox") || selectedElement.id === "eyePosition"){
                        if(dx && dy){
                            // set the new translate
                            transform.setTranslate(dx,dy);
                        }
                    }
                        
                }
                // if the selected element is not null and the dragging flag is true
                else if (selectedElement && dragging) {
                
                    // get mouse coordinates
                    var coord = getMousePosition(event);
                    // calculate the difference in the two
                    var dx = parseInt(coord.x - offset.x);
                    var dy = parseInt(coord.y - offset.y);

                    // if the icon is confined check for boundry values
                    if (confined) {
                        if (dx < minX) { dx = minX; }
                        else if (dx > maxX) { dx = maxX; }
                        if (dy < minY) { dy = minY; }
                        else if (dy > maxY) { dy = maxY; }
                    }
                    // set the transform
                    transform.setTranslate(dx, dy);
                    
                }
            }

            // when mouseup or mouse leave the svg box reset all flags 
            // and set the selectedElement to null
            function endDrag(event) {
                
                if(selectedElement){
                    drag(event);
                    resizing = false;
                    dragging = false;
                    bottomL = false;
                    bottomR = false;
                    topL = false;
                    topR = false;
                    bottom = false;
                }
            selectedElement = null;
            }

            // given an icon element returnns the min scale value for each icon to test against the new scale
            function findLimit(selectedElement, isMin){
                if(selectedElement && selectedElement !== 'null'){
                    if(isMin){
                        if(selectedElement.id.indexOf('north') !== -1){
                            return minNorth;
                        }
                        else if(selectedElement.id.indexOf('sun') !== -1){
                            return minSun;
                        }
                        else if(selectedElement.id.indexOf('eye') !== -1){
                            return minEye;
                        }
                        else if(selectedElement.id.indexOf('attension') !== -1){
                            return outlineMin;
                        }
                        else if(selectedElement.getAttribute("class") && selectedElement.getAttribute("class").indexOf('text') !== -1){
                            return minText;
                        } else{
                            return .05;
                        }
                    }
                    else{
                        if(selectedElement.id.indexOf('north') !== -1){
                            return maxNorth;
                        }
                        else if(selectedElement.id.indexOf('sun') !== -1){
                            return maxSun;
                        }
                        else if(selectedElement.id.indexOf('eye') !== -1){
                            return maxEye;
                        }
                        else if(selectedElement.getAttribute("class") && selectedElement.getAttribute("class").indexOf('text') !== -1){
                            return maxText;
                        }else{
                            return 2;
                        }
                    }
                }
            }        
        }// end make dragable

    </script>

    <body>
        <!-- Page Header Block-->
        <img src="../images/usgsLogo.png" class="float-md-left" width="15%" height="auto" style="margin: 0%; padding: 0%">
        <!-- Loading GIF-->
        <div id="loading" class="float-md-right text-center lead loading">
                <img src="../images/loading.gif" class='float-center;' height="100%" weight="auto"/>
                <br>
                <h3 id="loadingText" style="text-align: center; margin-left: 1rem;">Loading</h3>
            </div>
        <div class="container" style="background: #e7c492; height: 12rem; padding: 2rem; border: 1px solid black;">
            <img src="/images/help.jpg" class="float-right helpBtn" id="helpBtn"/>
            <div class="jumbotron text-center" style="border: 1px solid black; background: #f3d6b0; height:7rem; padding: 0;">
                <h2>Edit Cube Image</h2> 
                <h4 id="imageName"></h4>  
                <h5><%=w%> &times; <%=h%> px</h5>   
                <button class="btn btn-primary btn-lg float-left" onclick="captionHandler()" style="border: 2px solid black; width: auto; height: 2.5rem; padding:5;">
                    View Caption
                </button>
                <a class="btn btn-primary btn-lg float-right" style="border: 2px solid black; width: auto; height: 2.5rem; padding:5;" href="/" role="button">New Upload</a>
            </div>
        </div>
        <br/>
        <!-----------------------Editor Box----------------------------------------------->
        <svg id="svgWrapper" xmlns="http://www.w3.org/2000/svg" version='1.1' stroke="black" fill="black"  xmlns:xlink="http://www.w3.org/1999/xlink" 
        class="image-image" viewBox="0 0 <%=w%> <%=h%>" style="fill:black;" width='<%=w%>' height='<%=h%>'> 
            <rect id="svgBackground" x="0" y="0" width="<%=w%>" height="<%=h%>" fill="black"/>
            <image id="crop" style="pointer-events: none;" width="<%=w%>" height="<%=h%>" x="0" y="0" transform="scale(.25)"fill="black" xlink:href="/images/loading.gif"/>  
            
        </svg>

        <!--------------------------- Help Box ------------------------->
        <div class="help-box-right" id="help-box" style="visibility: hidden;">
            <button class="float-right helpBtn" id="hideBtn" 
            style="width: auto; height:auto; border-radius: 5px; border: 1px solid red; background-image: linear-gradient(lightblue,rgba(50, 50, 255, 0.685));background-color: rgba(39, 109, 200); color: darkred;">&times;</button>
                <div class="container title" style="background: whitesmoke;font-size: 2rem;">Help</div>
                <div class="row lead">1. Add Icons with the corresponding buttons.
                    <p class="small-text">(North Arrow, Sun Azimuthal Direction, Observer Direction, Scalebar)</p>
                    <p class="small-text">(Remove any icon by clicking the same button)</p>
                </div>
                <br/>
                <div class="row lead">2. Drag icons around the image with the mouse</div>
                <br/>
                <div class="row lead"> 3. Scale all icons and text by mousing over the corners of the object</div>
                <br/>
                <div class="row lead"> 4. Draw lines using the Pencil Tool.  
                    <p class="small-text">(Click 1 time to place the head of the line. Click again to finish drawing.
                         Use Esc key to remove the head after the first click)</p> 
                </div>
                <div class="row lead"> 5. Use the color pickers to change the color of the adjacent object.  
                        <p class="small-text">(Text, Pencil Tool, and Outline Boxes)</p> 
                </div>
                <br/>
                <div class="row lead"> 6. Add text to the image by clicking on the text box button and typing your text. 
                        <p class="small-text">(Undo a text element by clicking the red button.)</p>  
                </div>
                <br/>
                <div class="row lead"> 7. Padding can be added to the image by typing the amount 
                    of pixels you want to add, and then selecting a location.  
                </div>
                <br/>
                <div class="row lead"> 8. Click the 'Export Figure' button to save the new figure as an accepted format  
                       <p class="small-text">(Accepted Formats: png, svg, jpeg, or jpg)</p>
                </div>
            </div>

        <!-- Button Interface-->
        <div class="container float-left" style=" top: 9%; width: 20%; height: 5%; position: absolute;
                                                 padding: 2%; margin-left: auto; left: auto; right: auto;
                                                 border-right: 0%; margin-right: auto;">
            <br/>
            <div class="image-controls">
                <h2 class="text-right float-left" style="position: inherit; left: 8rem;">Tools</h2>
                <br/>
                <table style="width: 10rem; height:100%; table-layout:auto;">
                    <tr>
                        <th colspan="2" class="text-left float-center">
                            <!-- <li><button class="btn btn-primary btn-lg float-center" id="cropFlag"> Crop Image</button></li> -->
                            <!-- <li><button id="backBtn" class="btn btn-secondary btn-lg" onclick="loaderActivate()">Undo Crop</button></li> -->
                            
                            <li style="margin-top:.5rem; border-top: 4px solid black">
                                <p class="float-left" style="margin-right: .5rem;">North <br/>Azimuthal <br/>Direction</p>
                                <img class="btn btn-lg button" id="northIconFlag" src="/images/north.png"></img>
                                
                                <label id="northCheckboxLabel" for="northCheckbox" style="visibility: hidden">Toggle Color</label>
                                <input class="form-check-input largeBox" type="checkbox" id="northCheckbox" style="visibility: hidden; top:6rem; left: 17rem;">
                                
                            </li>
                            <li>
                                <p class="float-left" style="margin-right: .5rem;">Sun <br/>Azimuthal <br/>Direction</p>
                                <img class="btn btn-lg button" id="sunIconFlag"src="/images/sun_symbol.png"></img>
                                <label id="sunCheckboxLabel" for="sunCheckbox" style="top: 20rem; visibility: hidden;">Toggle Color</label>
                                <input class="form-check-input largeBox" type="checkbox" id="sunCheckbox" style="top: 11rem; left: 17rem; visibility: hidden;">
                            </li>
                            <li>
                                <p class="float-left" style="margin-right: .5rem;">Observer <br/>Azimuthal <br/>Direction</p>
                                <img class="btn btn-lg button" id="eyeFlag"  src="/images/eye_symbol.png"></img>
                                <label id="eyeCheckboxLabel" for="eyeCheckbox" style="top: 20rem; visibility: hidden;">Toggle Color</label>
                                <input class="form-check-input largeBox" type="checkbox" id="eyeCheckbox" style="top: 15.5rem; left: 17rem; visibility: hidden;">
                            </li>
                            <li>
                                <img class="btn btn-lg button" id="pencilIconFlag" src="/images/pencil.png"></img>
                                <p class="float-left" style="margin-right: 1.25rem; padding-top: .5rem;">Drawing <br/>Tool</p>
                                <input id="colorPickerLine"type="color" name="lineColor"  value="#ffffff"/> 
                                <button class="btn btn-danger btn-sm" id="undoLine" style="visibility: hidden;">Undo</button>
                            </li>
                            <li>
                                <p class="float-left" style="margin-right: .5rem; padding-top: .5rem;">Scalebar</p>
                                <button class="btn btn-lg button" id="scaleBarButton" style="width:9rem; color: black">
                                    <svg viewBox= "0 0 25 4">
                                        <rect x="0" y="0" id="scalebarOuter" width="25" height="4" stroke-width=".5" stroke="black" fill="white" ></rect>
                                        <path id="scalebarLine" d="M 15 2 L 25 2"  stroke="black" stroke-width=".75"/>
                                        <path id="scalebarVert" d="M 15 0 L 15 4"  stroke="black" stroke-width=".75"/>
                                        <path id="scalebarVert10th" d="M 0 0 L 0 4"  stroke="black" stroke-width="1"/>
                                        <path id="scalebarLine10th" d="M 0 2 L 2.5 2"  stroke="black" stroke-width=".75"/>
                                        <path id="scalebarVert20th" d="M 2.5 0 L 2.5 4"  stroke="black" stroke-width=".75"/>
                                        <path id="scalebarVert30th" d="M 5 0 L 5 4"  stroke="black" stroke-width=".75"/>
                                      
                                        <path id="scalebarVert40th" d="M 7.5 0 L 7.5 4"  stroke="black" stroke-width=".75"/>
                                        <path id="scalebarVert50th" d="M 10 0 L 10 4"  stroke="black" stroke-width=".75"/>
                                        <path id="scalebarVert50th" d="M 12.5 0 L 12.5 4"  stroke="black" stroke-width=".75"/>
                                        <path id="scalebarLine70th" d="M 5 2 L 7.5 2"  stroke="black" stroke-width=".75"/>
                                        <path id="scalebarLine90th" d="M 10 2 L 12.5 2"  stroke="black" stroke-width=".75"/>
                                    
                                    </svg>
                                </button>
                                <label id="scaleCheckboxLabel" for="scaleCheckbox" style="visibility: hidden; margin-top:.5rem; margin-bottom: 0;">Toggle Color</label>
                                <input class="form-check-input largeBox" type="checkbox" id="scaleCheckbox" style="top: 25rem; left: 16rem; visibility: hidden;">
                            </li>
                            <li>
                                <p class="float-left" style="margin-right: 1rem; padding-top: .5rem;">Outline <br/>Box</p>
                                <button class="btn btn-lg button" id="outlineBtn" style="width:4.5rem; color: black">
                                <svg viewBox="0 0 2 1.5">
                                    <rect x="0" y="0" width="2" height="1.5" stroke="white" stroke-width=".5" fill="transparent"></rect>
                                </svg>
                                </button>
                                
                                <input id="colorPickerBox"type="color" name="boxColor"  value="#ffffff"/> 
                                <button class="btn btn-danger btn-sm" style="visibility: hidden;" id="undoBox">Undo</button>
                            </li>
                            <li>
                                <p class="float-left" style="margin-right: 2rem; padding-top: .5rem;">Text <br/>Tool</p>
                                <button class="btn btn-lg button" id="textBtn" style="width:6rem; color: black">
                                <svg viewBox="0 0 20 8">
                                    <rect x="0" y="0" width="20" height="8"stroke="white" stroke-width="1"fill="transparent"></rect>
                                    <text x="3" y="7" font-size="9">Aa</text>
                                </svg>
                                </button>
                                <input type="color" id="textColorPicker" style="top: 48.5rem; left: 16rem;" value="#FFFFFF">
                                <button class="btn btn-danger btn-sm" style="visibility: hidden;" id="undoText">Undo</button>
                            </li>
                            <li style=" height: 12rem; width: auto; padding: 0; padding-top: 0rem; padding-left: 1rem;">
                                <h2 class="text-left" style="padding-left: .5rem; color: white;"> Pad Image</h2>
                                <div class="row" style="padding:0; padding-left: 1rem; width: 20rem; height: 4rem;">
                                        <div class="col" style="padding:0; margin-right: 1rem;">
                                            <input class="form-control form-control-lg" style="width: 10rem; border: 1px solid lightgrey;"id="paddingInput" type="text" placeholder="Pad Pixels"/>
                                        </div>
                                        <div class="col" style="padding:0; padding-left: 1rem; padding-top: 1%">
                                            <button  style="left: 15rem; top: 0rem;" class="btn btn-danger btn-md button" id="resetPaddingBtn"> Reset </button>
                                        </div>
                                </div>
                            
                                <div class="row" style="padding:0; padding-left: 1rem; width: 20rem;">
                                    <div class="col" style="top:0; padding: 0; left: 0rem;">
                                        <button class="btn button btn-md" id="topPaddingBtn"> Top </button> 
                                    </div>
                                    <div class="col" style="top:0rem; padding: 0; left: 0rem;">
                                        <button class="btn button btn-md" id="bottomPaddingBtn"> Bottom </button>
                                    </div>
                                
                                    <div class="col"style="top:0rem;padding: 0; left: 0rem;">
                                        <button class="btn button btn-md" id="leftPaddingBtn"> Left </button> 
                                    </div>
                                    <div class="col"style="text-outline: 0rem; padding: 0; left: 0rem;">
                                        <button class="btn button btn-md" id="rightPaddingBtn"> Right </button> 
                                    </div>
                                </div>
                            </li>
                            <li style="border-bottom: 4px solid black;">
                                <div class="row" style="padding:0; padding-left: 1rem; width: 20rem;">
                                    <div class="col" style="padding: 0; top: 0rem">
                                        <p class="float-left" style="margin-right: 2rem; padding-top: .5rem;">Save <br/>Figure</p>
                                        <button class="btn btn-primary btn-lg button" style="width: 4rem;" id="exportBtn" > 
                                            <svg viewBox="0 0 20 25">
                                                <path d="M 0 0 L 15 0 L 20 5 L 20 25 L 0 25 L 0 0"></path>
                                                <path d="M 3 3.5 L 3 10 a1,1 0 0 0 1,1 L 13 11 a1,1 0 0 0 1,-1 L 14 3.5 a1,1 0 0 0 -1,-1 L 4 2.5 a1,1 0 0 0 -1,1" 
                                                fill="white" stroke="white"></path>
                                                <path d="M 12 4 L 12 9 a2.5,2.5 0 0 1 -3,0 L 9 4 a2.5,2.5 0 0 1 3,0 L 12 5" stroke="black" fill="black"></path>
                                                <path d="M 2 15.5 L 2 22 a1,1 0 0 0 1,1 L 17 23 a1,1 0 0 0 1,-1 L 18 15.5 a1,1 0 0 0 -1,-1 L 3 14.5 a1,1 0 0 0 -1,1" 
                                                fill="white" stroke="white"></path>
                                            </svg>
                                        </button>
                                    </div>
                                </div>
                            </li>
                        </th>
                    </tr>
                </table>
            </div>
        </div>
        
        <br/>
        <!-- Hidden Tags for data parsing-->
        <div id="metadata" style="display:none;"  class="text-center green-border-focus">
                <label for="metadata-text">
                    <h2>Metadata Output</h2>
                </label>
                <textarea readonly id="metadata-text" class="form-control bg-white text-dark" style="resize: vertical; font-size: 22px;"><%= tagField %></textarea>
            </div>
        
            <div id="metadata-tags" style="display:none;" class="text-center green-border-focus">
                <label for="metadataTagArea">
                    <h2>Metadata Tags</h2>
                </label>
                <textarea readonly id="metadataTagArea" class="form-control bg-white text-dark" style="resize: vertical; font-size: 22px;"></textarea>
            </div>
            <!-- Canvas for extracting inline svg-->
            <canvas id="canvas" width="<%=w%>" height="<%=h%>" style="display:none; border: 5px solid black; fill: black;" ></canvas>


        <script type="text/javascript">
            // preserves the data on the writer page if it was the last seen page before the image editor
            function captionHandler(){
                // if the last window seen was captionWriter then go back to preserve changes
                if(document.referrer.indexOf("/captionWriter") > -1){
                    window.history.back();
                }else{
                    // else reload the page
                    window.open('/captionWriter','_self');
                }
            }

            // string version of the icons so they can be added dynamically with a single function call 
           
            var sunObjectString = '<g id="sunPosition" class="draggable confine" transform-origin="50%; 50%;" transform="translate(100,150) rotate(0) scale(.15625)"  stroke-width="7" style="border:0; padding:0; pointer-events:visible;"> '
                    +'<circle id= "sunIconOuter"  r="125" cy="175" cx="150" stroke-width="15" stroke="white" fill="black" style="border:0;"></circle>'
                    +'<circle id= "sunIcon"  r="25" cy="175" cx="150" fill="white" stroke="black" style="border:0;"></circle>'
                    + '<path d="M 150 0 L 250 50 L 150 0 L 50 50 L 150 25 L 250 50" stroke="black"  fill="white" stroke-width="10"/>'
                    +'<rect class="resize top-left"x="0" y="0" width="100" height="100" style="visibility: hidden;"fill="red"/>'
                    +'<rect class="resize top-right"x="220" y="0" width="100" height="100" style="visibility: hidden;"fill="blue"/>'
                    +'<rect class="resize bottom-right"x="220" y="200" width="100" height="100" style="visibility: hidden;"fill="green"/>'
                    +'<rect class="resize bottom-left"x="0" y="200" width="100" height="100" style="visibility: hidden;"fill="yellow"/></g>';
        
          
            var northObjectString = '<g id="northPosition" class="draggable confine" transform-origin="50%; 50%;"  transform="translate(100,100) rotate(0) scale(.1219513)" stroke-width="7" style="border:0; padding:0; pointer-events:all;">'
                +'<rect x="0" y="0" id="northBG"style="visibility: visible;"width="200" height="400" fill="black"/>'
                +'<rect x="0" y="0" class="resize top-left" style="visibility: hidden;"width="100" height="125" fill="red"/>'
                +'<rect x="100" y="0" class="resize top-right" style="visibility: hidden;"width="100" height="150" fill="yellow"/>'
                +'<path id= "northIcon"  d="M 100 0 L 200 200 L 100 150 L 0 200 Z" fill="white"  stroke="black" stroke-width="4" style="border:0;"></path>'
                +'<path id="nLetter" d="M 50 200 L 50 0 L 150 200 L 150 0"stroke="white" stroke-width="10" transform="translate(0,200)"fill="black" style="border:0;"></path>'
                +'<rect class= "resize bottom-right"x="100" y="300" width="110" height="110" style="visibility: hidden;"fill="green"/>'
                +'<rect class= "resize bottom-left"x="0" y="300" width="110" height="110" style="visibility: hidden;"fill="blue"/></g>'
                

            var outlineObjectString = '<rect id="cropOutline" x="0" y="0" width="5" height="5" style="fill:rgba(245, 13, 13, 0.15);pointer-events:none; stroke-width:2;stroke:rgb(255,0,0);" />';

            var attensionBoxObjectString ='<rect id="attensionBox" x="0" y="0" width="400" height="400" />'
                + '<rect class=" resize top-left" x="0" y="0" width="125" height="125" style="visibility: hidden;fill:rgba(245, 13, 13, 0.15); stroke-width:2;stroke:blue" />'
                + '<rect class=" resize top-right" x="275" y="0" width="125" height="125" style="visibility: hidden;fill:rgba(245, 13, 13, 0.15); stroke-width:2;stroke:blue" />'
                + '<rect class=" resize bottom-right" x="275" y="275" width="125" height="125" style="visibility: hidden;fill:rgba(245, 13, 13, 0.15); stroke-width:2;stroke:blue" />'
                + '<rect class=" resize bottom-left" x="0" y="275" width="125" height="125" style="visibility: hidden;fill:rgba(245, 13, 13, 0.15); stroke-width:2;stroke:blue" />';
            
            var eyeObjectString = '<g id="eyePosition" class="draggable confine" transform-origin="50%; 50%;" transform="translate(0,100) rotate(0) scale(.52)" stroke-width="3" style="border:0; padding:0; pointer-events:visible;">'
                + '<path id="eyeArrow"x="0" y="0" transform="translate(0,0) rotate(0,150,115)"  stroke-width="2" d="M 76.5 0 L 55 21.6 L 73.5 21.6 L 73.5 65 L78.5 65 L 78.5 21.6  L 95 21.6 L 74.5 0" stroke="white" fill="black"/>'
                + '<ellipse id= "eyeIconOuter"  cx="75" cy="55" rx="37" ry="25"  stroke="white" fill="black" style="border:0;"></ellipse>'
                + '<ellipse id= "eyeIconCenter" rx="18" ry="20" cy="55" cx="75" stroke-width="3" fill="white" stroke="black"  style="border:0;">'
                + '</ellipse><circle id= "eyeIconPupel"  r="7"cy="55" cx="75" stroke-width="4" stroke="white" fill="black"  style="border:0;"></circle>'
                + '<rect x="0" y="0" class="resize top-left" style="visibility: hidden;"width="55" height="50" fill="red"/>'
                + '<rect x="88" y="0" class="resize top-right" style="visibility: hidden;"width="47" height="45" fill="blue"/>'
                + '<rect x="88" y="67" class="resize bottom-right" style="visibility:hidden;"width="47" height="40" fill="green"/>'
                + '<rect x="1" y="65" class="resize bottom-left" style="visibility: hidden;"width="55" height="40" fill="yellow"/></g>';
            
            var scaleBarObject = '<g id="scalebarPosition"class="draggable confine scalebar" transform="translate(0,175) scale(.1)" stroke-width="10" style="border:0; padding:0; pointer-events:all;">'
                + '<rect x="0" y="0" id="scalebarBG" width="4250" height="500" style="visibility:hidden;"></rect>'
                + '<rect x="150" y="200" id="scalebarOuter" width="4000" height="300"stroke-width="20" stroke="white" fill="black" ></rect>'
                + '<path id="scalebarLine" d="M 2150 350 L 4150 350"  stroke="white" stroke-width="50"/>'
                + '<path id="scalebarVert" d="M 2150 200 L 2150 500"  stroke="white" stroke-width="20"/>'
                + '<path id="scalebarVert10th" d="M 350 200 L 350 500"  stroke="white" stroke-width="20"/>'
                + '<path id="scalebarLine10th" d="M 150 350 L 350 350"  stroke="white" stroke-width="50"/>'

                + '<path id="scalebarVert20th" d="M 550 200 L 550 500"  stroke="white" stroke-width="20"/>'
                + '<path id="scalebarVert30th" d="M 750 200 L 750 500"  stroke="white" stroke-width="20"/>'
                + '<path id="scalebarLine30th" d="M 550 350 L 750 350"  stroke="white" stroke-width="50"/>'

                + '<path id="scalebarVert40th" d="M 950 200 L 950 500"  stroke="white" stroke-width="20"/>'
                + '<path id="scalebarVert50th" d="M 1150 200 L 1150 500"  stroke="white" stroke-width="20"/>'
                + '<path id="scalebarLine50th" d="M 950 350 L 1150 350"  stroke="white" stroke-width="50"/>'

                + '<path id="scalebarVert60th" d="M 1350 200 L 1350 500"  stroke="white" stroke-width="20"/>'
                + '<path id="scalebarVert70th" d="M 1550 200 L 1550 500"  stroke="white" stroke-width="20"/>'
                + '<path id="scalebarLine70th" d="M 1350 350 L 1550 350"  stroke="white" stroke-width="50"/>'

                + '<path id="scalebarVert80th" d="M 1750 200 L 1750 500"  stroke="white" stroke-width="20"/>'
                + '<path id="scalebarVert90th" d="M 1950 200 L 1950 500"  stroke="white" stroke-width="20"/>'
                + '<path id="scalebarLine90th" d="M 1750 350 L 1950 350"  stroke="white" stroke-width="50"/>'

                + '<text id="scalebarText" x="3950" y="150" font-family="sans-serif" font-size="150" stroke="white"fill="white"><%=scalebarLength%><%=scalebarUnits%></text>'
                + '<text id="scalebar1" x="50" y="150" font-family="sans-serif" font-size="150" stroke="white"fill="white"> <%=scalebarLength%></text>'
                + '<text id="scalebarHalf" x="1050" y="150" font-family="sans-serif" font-size="150" stroke="white"fill="white"></text>'
                + '<text id="scalebar0" x="2100" y="150" font-family="sans-serif" font-size="150" stroke="white"fill="white">0</text></g>';


            // grab DOM elements that are needed
            var exportBtn =  document.getElementById('exportBtn');
            var myImage = document.getElementById('crop');
            var svg = document.getElementById('svgWrapper');
            var loader = document.getElementById('loading');


            myImage.setAttribute("x",parseInt("<%=w%>")*1.5 + "px");
            myImage.setAttribute("y",parseInt("<%=h%>")*1.25 + "px");
           

            // dynamically add the elements to export better 
            svg.insertAdjacentHTML("beforeend",sunObjectString);
            svg.insertAdjacentHTML("beforeend",northObjectString);
            svg.insertAdjacentHTML('beforeend',outlineObjectString);
            svg.insertAdjacentHTML("beforeend",eyeObjectString);
            svg.insertAdjacentHTML("beforeend",scaleBarObject);
           
            // save the elements to dynamically add and remove them with a single line of code
            var sunImage = document.getElementById("sunPosition"),
                northImage = document.getElementById("northPosition"),
                outlineBox = document.getElementById('cropOutline'),
                eyeImage = document.getElementById('eyePosition'),
                eyeArrow = document.getElementById("eyeArrow"),
                scaleBarIcon = document.getElementById('scalebarPosition');

            // get half the scalebar length for drawing
            let half = parseFloat("<%=scalebarLength%>")/2;

            // get needed dimension values
            let scalePX = parseFloat("<%=scalebarPx%>"),
                w = parseInt("<%=w%>"),
                h = parseInt("<%=h%>"),
                origW = parseInt("<%=origW%>"),
                origH = parseInt("<%=origH%>"),
                textSize;
        
            // if the scale bar is not none
            if('<%=scalebarPx%>' !== 'none'){
                // set the size based on how the image is drawn
                if((w/origW) < (h/origH)){
                    scaleBarIcon.setAttribute("transform","translate(0,175) scale(" + (scalePX/4000)* 2 * (w/origW) + ')');
                    // set text box font to 11X the scale of the scale bar to account for the change in pixel sizes 
                    textSize = (scalePX/4000)* 21 * (w/origW);
                }else{
                    scaleBarIcon.setAttribute("transform","translate(0,175) scale(" + (scalePX/4000)* 2 * (h/origH) + ')');
                    // set text box font to 11X the scale of the scale bar to account for the change in pixel sizes
                    textSize = (scalePX/4000)* 21 * (h/origH);
                }
                
                // if half the bar is less than 1 km then give it the decimal
                if(half < 1){
                    document.getElementById("scalebarHalf").innerHTML = half;
                }
                // otherwise parse it to the closest int
                else{
                    document.getElementById("scalebarHalf").innerHTML = parseInt(half);
                }
            }
            else{
                // if the scalebarPx is none disable the button
                document.getElementById("scaleBarButton").setAttribute("class","btn btn-secondary btn-lg button disabled"); 
                // set deafult font size for text boxes note that this is a scale value not px size  (px = font size * textSize)
                textSize = 2;
            }

            // remove the objects because they are not needed yet
            northImage.remove();
            sunImage.remove();
            outlineBox.remove();
            eyeImage.remove();
            scaleBarIcon.remove();
            
            // set defaults
            outlineBox.style.visibility = 'hidden';

            // function to hide the loading gif
            function loadInvisible(){
                loader.style.visibility = 'hidden';    
            }
            // function to show the loading gif
            function loaderActivate(){
                loader.style.visibility = 'visible';
            }

            
            console.log(" image dimensions are => <%= w %>: <%= h %>");
            // set loader to invisible
            loadInvisible();
        
            // toggle colors tracker
            var toggleScalebar = true,
                userTextColor;

            // sets the display name
            document.getElementById("imageName").innerHTML = "<%=displayCube%>";
            
            // when the box check value changes switch the fills and strokes
            $("#northCheckbox").on("change",function(){
                // get all children in the group
                let children = northImage.childNodes;
                
                // for each child
                for(index in children){
                    // if the child is an object
                    if(typeof(children[index]) == "object"){
                        // call opposite for fill and stroke
                        if(children[index].getAttribute("stroke")){
                            children[index].setAttribute("stroke",setOpposite(children[index].getAttribute("stroke")));
                        }
                        if(children[index].getAttribute("fill")){
                            children[index].setAttribute("fill",setOpposite(children[index].getAttribute("fill")));
                        }
                    }
                }
            });

            // same inversion as above
            $("#sunCheckbox").on("change",function(){
                let children = sunImage.childNodes;
                
                for(index in children){
                    if(typeof(children[index]) == "object" && children[index].nodeName !== "#text"){
                        if(children[index].getAttribute("stroke")){
                            children[index].setAttribute("stroke",setOpposite(children[index].getAttribute("stroke")));
                        }
                        if(children[index].getAttribute("fill")){
                            children[index].setAttribute("fill",setOpposite(children[index].getAttribute("fill")));
                        }
                
                    }
                }
            });

            // same as above
            $("#scaleCheckbox").on("change",function(){
                
                var children = scaleBarIcon.childNodes;

                for(index in children){
                    if(typeof(children[index]) == "object"){
                        if(children[index].getAttribute("stroke")){
                            children[index].setAttribute("stroke",setOpposite(children[index].getAttribute("stroke")));
                        }
                        if(children[index].getAttribute("fill")){
                            children[index].setAttribute("fill",setOpposite(children[index].getAttribute("fill")));
                        }
                
                    }
                }
            });


            // reverses black and white fills for icons
            function setOpposite(colorString){
                if(colorString === "black"){return "white";}
                else{return "black";}
            }

            // same as above
            $("#eyeCheckbox").on("change",function(){
                let children = eyeImage.childNodes;
                
                for(index in children){
                    if(typeof(children[index]) == "object"){
                        if(children[index].getAttribute("stroke")){
                            children[index].setAttribute("stroke",setOpposite(children[index].getAttribute("stroke")));
                        }
                        if(children[index].getAttribute("fill")){
                            children[index].setAttribute("fill",setOpposite(children[index].getAttribute("fill")));
                        }
                
                    }
                }
            });

            // toggle scalebar by appending and removing it
            $("#scaleBarButton").on("mousedown",function(){
                // if the scalebar btn is not disabled
                if(!this.classList.contains("disabled")){
                    // if scalebar true then toggle the bar on
                    if(toggleScalebar){
                        // add bar and toggle the boolean
                        svg.appendChild(scaleBarIcon);
                        this.className = "btn btn-danger btn-lg button";

                        document.getElementById("scaleCheckbox").style.visibility = "visible";
                        document.getElementById("scaleCheckboxLabel").style.visibility = "visible";

                        toggleScalebar = false;
                    }else{
                        // remove the bar and reset toggleValue
                        scaleBarIcon.remove();
                        toggleScalebar = true;
                        this.className = "btn btn-lg button";
                        document.getElementById("scaleCheckbox").style.visibility = "hidden";
                        document.getElementById("scaleCheckboxLabel").style.visibility = "hidden";
                    }
                }
            });
        
        </script>


        <script type="text/javascript">
            // function to convert client pixel values to svg DOM relative values

            function svgPoint(element, x, y) {
                // get a new svg point
                var pt = svg.createSVGPoint();
                // set the point x value to the passed x
                pt.x = x;
                // same for y
                pt.y = y;

                /* use matrixTransform to convert the x and y using getScreenCTM to capture
                    the browsers coordinate matrix */
                return pt.matrixTransform(element.getScreenCTM().inverse());    
            }
            

            /**
            * converts image to a data url so that when exporting all that is needed 
            * is to convert the svg block to a canvas and then export as an image
            **/
            const toDataURL = url => fetch(url)
            .then(response => response.blob())
            .then(blob => new Promise((resolve, reject) => {
                const reader = new FileReader()
                reader.onloadend = () => resolve(reader.result)
                reader.onerror = reject
                reader.readAsDataURL(blob)
            }));


            const b64toBlob = (b64Data, contentType='', sliceSize=512) => {
                const byteCharacters = atob(b64Data);
                const byteArrays = [];

                for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
                    const slice = byteCharacters.slice(offset, offset + sliceSize);

                    const byteNumbers = new Array(slice.length);
                    for (let i = 0; i < slice.length; i++) {
                    byteNumbers[i] = slice.charCodeAt(i);
                    }

                    const byteArray = new Uint8Array(byteNumbers);
                    byteArrays.push(byteArray);
                }

                const blob = new Blob(byteArrays, {type: contentType});
                return blob;
                }



        </script>

        <script type="text/javascript">

            // set all flags to false to start
            var sunIconPlaced = false,
                northIconPlaced = false,
                eyeIconPlaced = false,
                doneResizing = false,
                northFlag = false,
                cropFlag = false, 
                sunFlag = false,
                eyeFlag = false,
                attensionBoxVisible = false;

            //create clickArray
            var clickArray = [];

            // on doc ready run the button logic and click capturing events
            $(document).ready(function() {
                // reset click array on a new load
                clickArray = [];
                
                // get the draggable svg element
                var svgDOM = document.getElementById('svgWrapper');
                // get the image from the link
                var myImage = document.getElementById('crop');

                // start the draggable svg element
                makeDraggable(svgDOM);

                // converts raw image format to base 64 data
                toDataURL('/<%=image%>')
                    .then(dataUrl => {
                        // get the window URL element on any browser
                        let DOMURL = window.URL || window.webkitURL || window;

                        // set the data equal to the image display
                        // set image link to nothing to remove the loading image before a load operation
                        myImage.setAttributeNS("http://www.w3.org/1999/xlink",'xlink:href', "");
                        myImage.setAttributeNS("http://www.w3.org/1999/xlink",'xlink:href', dataUrl);

                        

                        // remove the data url from the memory because it is saved in the xlink now
                        DOMURL.revokeObjectURL(dataUrl);
                    }).then(function(){
                        // default all transforms
                        myImage.setAttribute("x","0");
                        myImage.setAttribute("y","0");
                        myImage.setAttribute("transform","scale(1)");
                        

                    });

                    
                
                // get padding input box and other important DOM elements for export
                var paddingBoxInput = document.getElementById("paddingInput"),
                    bg = document.getElementById("svgBackground"),
                    canvas = document.getElementById("canvas");
                
                // init the padding value
                paddingBoxInput.value = '';
                
                // function that adjusts the view box and background to add padding to the image
                function setImagePadding(val,location){
                    // image w and h vars
                    let imageW,
                        imageH;

                    // switch on the location of the padding
                    switch(location){
                        // if bottom padding
                        case 'bottom':
                            // get the new image height for the box and background
                            imageH = <%=h%> + val; 
                            // set the viewbox values to how on the bottom of the image
                            svgDOM.setAttribute("viewBox", "0 0 <%=w%> " + imageH);

                            // set background x,y to 0 to show at the bottom of the image
                            bg.setAttribute("x",0);
                            bg.setAttribute("y",0);

                            // adjust the height and set the width to what it should be
                            bg.setAttribute("height", imageH);
                            bg.setAttribute("width",<%=w%>);
                            // same with canvas to allow exporting the padding
                            canvas.setAttribute("height", imageH);
                            canvas.setAttribute("width",<%=w%>);
                            // fix the svg to properly export all content
                            svgDOM.setAttribute("height", imageH);
                            svgDOM.setAttribute("width",<%=w%>);
                            // call makeDraggable again to reset the boundaries of the draggable elements
                            makeDraggable(svgDOM);
                            break;

                        case "top":
                            // get the new image height for the box and background
                            imageH = <%=h%> + val;

                            console.log(imageH);
                            // set background x,y to show padding at the right spot
                            bg.setAttribute("y",val*-1);
                            bg.setAttribute("x",0);
                            // adjust the height and set the width to what it should be
                            bg.setAttribute("height",imageH);
                            bg.setAttribute("width",<%=w%>);
                            
                            // set the viewbox values 
                            svgDOM.setAttribute("viewBox", "0 " + String(val*-1) + " <%=w%> " + imageH);
                            // same with canvas to allow exporting the padding
                            canvas.setAttribute("height", imageH);
                            canvas.setAttribute("width",<%=w%>);
                            // fix the svg to properly export all content
                            svgDOM.setAttribute("height", imageH);
                            svgDOM.setAttribute("width",<%=w%>);
                            // call makeDraggable again to reset the boundaries of the draggable elements
                            makeDraggable(svgDOM);
                            break;

                        case "right":
                            // get the new image width for the box and background
                            imageW = <%=w%> + val;
                            // set background x,y to padding at the right spot
                            bg.setAttribute("y",0);
                            bg.setAttribute("x",0);
                            // adjust the height and set the width to what it should be
                            bg.setAttribute("width",imageW);
                            bg.setAttribute("height",<%=h%>);
                            
                            // set the viewbox values
                            svgDOM.setAttribute("viewBox", "0 0 "  + imageW + " <%=h%>");
                            // same with canvas to allow exporting the padding
                            canvas.setAttribute("width", imageW);
                            canvas.setAttribute("height",<%=h%>);
                            // fix the svg to properly export all content
                            svgDOM.setAttribute("width", imageW);
                            svgDOM.setAttribute("height",<%=h%>);
                            // call makeDraggable again to reset the boundaries of the draggable elements
                            makeDraggable(svgDOM);
                            break;


                        case "left":
                            // get the new image width for the box and background
                            imageW = <%=w%> + val;
                            // set background x,y to padding at the right spot
                            bg.setAttribute("y",0);
                            bg.setAttribute("x",val*-1);
                            // adjust the height and set the width to what it should be
                            bg.setAttribute("width",imageW);
                            bg.setAttribute("height",<%=h%>);
                            
                            // set the viewbox values 
                            svgDOM.setAttribute("viewBox",  String(val*-1)+ " 0 "  + imageW + " <%=h%>");
                            // same with canvas to allow exporting the padding
                            canvas.setAttribute("width", imageW);
                            canvas.setAttribute("height",<%=h%>);
                            // fix the svg to properly export all content
                            svgDOM.setAttribute("width", imageW);
                            svgDOM.setAttribute("height",<%=h%>);
                            // call makeDraggable again to reset the boundaries of the draggable elements
                            makeDraggable(svgDOM);
                            break;

                        default:
                            // get the new image width and height for the box and background
                            imageW = <%=w%>;
                            imageH = <%=h%>; 

                            // set background x,y to padding at the right spot                            
                            bg.setAttribute("x",0);
                            bg.setAttribute("y",0);
                            // adjust the height and set the width to what it should be
                            bg.setAttribute("width",imageW);
                            bg.setAttribute("height",imageH);

                            // set the viewbox values
                            svgDOM.setAttribute("viewBox", "0 0 <%=w%> <%=h%>");
                            // same with canvas to allow exporting the padding
                            canvas.setAttribute("width", <%=w%>);
                            canvas.setAttribute("height",<%=h%>);
                            // fix the svg to properly export all content
                            svgDOM.setAttribute("width", <%=w%>);
                            svgDOM.setAttribute("height",<%=h%>);
                            // call makeDraggable again to reset the boundaries of the draggable elements
                            makeDraggable(svgDOM);

                    }
                        
                    
                }

                let padBottom = false,
                    padTop = false,
                    padLeft = false,
                    padRight = false;

                let bottomBtn = document.getElementById("bottomPaddingBtn"),
                    topBtn = document.getElementById("topPaddingBtn"),
                    rightBtn = document.getElementById("rightPaddingBtn"),
                    leftBtn = document.getElementById("leftPaddingBtn");


                // jquery to detect a click on the padding buttons just call set function 
                // with either 0 or the padding input val and tell function where to place the padding 
                $("#bottomPaddingBtn").on('click',function(event){
                    if(!isNaN(parseInt(paddingBoxInput.value))){
                        setImagePadding(parseInt(paddingBoxInput.value),'bottom');
                        padBottom = true;
                        padLeft = false, padRight = false, padTop = false;

                        bottomBtn.className = 'btn btn-danger button btn-md disabled';

                        leftBtn.className = 'btn button btn-md';
                        rightBtn.className = 'btn button btn-md';
                        topBtn.className = 'btn button btn-md';

                    }else{
                        setImagePadding(parseInt(0),"none"); 
                        bottomBtn.className = 'btn button btn-md';
                        leftBtn.className = 'btn button btn-md';
                        rightBtn.className = 'btn button btn-md';
                        topBtn.className = 'btn button btn-md';
                        padBottom = false;  
                    }
                });

                $("#topPaddingBtn").on('click',function(event){
                    if(!isNaN(parseInt(paddingBoxInput.value))){
                        setImagePadding(parseInt(paddingBoxInput.value),'top');
                        padTop = true;

                        padLeft = false, padRight = false, padBottom = false;
                        
                        topBtn.className = 'btn btn-danger button btn-md disabled';

                        leftBtn.className = 'btn button btn-md';
                        rightBtn.className = 'btn button btn-md';
                        bottomBtn.className = 'btn button btn-md';
                    }else{
                        setImagePadding(parseInt(0),"none"); 
                        topBtn.className = 'btn button btn-md';

                        leftBtn.className = 'btn button btn-md';
                        rightBtn.className = 'btn button btn-md';
                        bottomBtn.className = 'btn button btn-md';
                        padTop = false;  
                    }
                });

                $("#rightPaddingBtn").on('click',function(event){
                   
                    if(!isNaN(parseInt(paddingBoxInput.value))){
                        setImagePadding(parseInt(paddingBoxInput.value),'right');
                        padRight = true;
                        
                        padLeft = false,
                        padBottom = false,
                        padTop = false;

                        rightBtn.className = 'btn btn-danger button btn-md disabled';

                        leftBtn.className = 'btn button btn-md';
                        bottomBtn.className = 'btn button btn-md';
                        topBtn.className = 'btn button btn-md';
                    }else{
                        setImagePadding(parseInt(0),"none"); 
                        rightBtn.className = 'btn button btn-md'; 

                        leftBtn.className = 'btn button btn-md';
                        bottomBtn.className = 'btn button btn-md';
                        topBtn.className = 'btn button btn-md';
                        padRight = false; 
                    } 
               });

               $("#leftPaddingBtn").on('click',function(event){
                   
                   if(!isNaN(parseInt(paddingBoxInput.value))){
                       setImagePadding(parseInt(paddingBoxInput.value),'left');
                       padLeft = true;
                       padBottom = false,
                       padRight=false, 
                       padTop = false;
                       
                       leftBtn.className = 'btn btn-danger button btn-md disabled';
                       
                       bottomBtn.className = 'btn button btn-md';
                       rightBtn.className = 'btn button btn-md';
                       topBtn.className = 'btn button btn-md';
                   }else{
                       setImagePadding(parseInt(0),"none"); 
                       leftBtn.className = 'btn button btn-md'; 
                       bottomBtn.className = 'btn button btn-md';
                       rightBtn.className = 'btn button btn-md';
                       topBtn.className = 'btn button btn-md';
                       padLeft = false; 
                   } 
              });

                $("#resetPaddingBtn").on('click',function(event){
                   
                    setImagePadding(parseInt(0),"none"); 
                    paddingBoxInput.value = "";  
                    
                    padBottom = false, padLeft = false, padRight = false, padTop = false;
                    
                    bottomBtn.className = 'btn button btn-md';
                    leftBtn.className = 'btn button btn-md';
                    rightBtn.className = 'btn button btn-md';
                    topBtn.className = 'btn button btn-md';
                    
                });


                var warned = false;
                // chnages the padding whenever padding has been applied and the box chnages values
                $("#paddingInput").keyup(function(){
                    if(!isNaN(parseInt(this.value))){
                        if(padBottom){
                            setImagePadding(parseInt(this.value),'bottom');
                        }
                        else if(padRight){
                            setImagePadding(parseInt(this.value),'right');
                        }
                        else if(padLeft){
                            setImagePadding(parseInt(this.value),'left');
                        }
                        else if(padTop){
                            setImagePadding(parseInt(this.value),'top');
                        }
                    }else{
                        if(this.value !== "" && !warned){
                            alert("Only Accepts Whole Numbers");
                            warned = true;
                        }
                        $("#resetPaddingBtn").click();
                    }
                });


                /* 
                // when the image registers a click
                $("image").on("click", function(event) {
                    event.preventDefault();
                    // capture event variables for px calculations
                    var t = event.target;
                    var x = event.pageX;
                    var y = event.pageY;
                
                    // if the target is the svg DOM then keep it the same 
                      //  otherwise set it to the parent of the current target 
                    var target = (t == svg ? svg : t.parentNode);
                    // get the converted svg coordinates
                    var svgP = svgPoint(target, x, y);
                    // convert floats to integers
                    var x = parseInt(svgP.x),
                        y = parseInt(svgP.y);
                
                    // ======== FOR TESTING=======
                    console.log("x is: " + x);
                    console.log("y is:" + y);
                    // ===========================

                    /* // if any of the flags are true
                    if(cropFlag){

                        // and if the click array is either length = 0 or the clicks are in 
                           // a proper location for cropping capture the click in the clickArray 
                        if(clickArray.length === 0){
                            captureClick(x,y);
                            // check click array
                            console.log(clickArray);
                        }else if(clickArray.length === 2){
                            
                            captureClick(x,y);
                            prepareCrop(clickArray);
                            
                            
                        }
                        
                        // Then if the click flag is true and the length of the array is 2
                        if(cropFlag && clickArray.length === 2){
                            // set the dimensions and visibilty of the outline box
                            outlineBox.style.visibility = 'visible';
                            svg.insert(outlineBox);
                            
                            outlineBox.setAttribute('x',clickArray[0]);
                            outlineBox.setAttribute('y',clickArray[1]);
                        }
                        // if the crop flag is true and the length of the click array is 4 crop the image
                        else if( cropFlag && clickArray.length === 4){
                            // activate loader gif 
                            loaderActivate();
                            // set done resizeing flag
                            doneResizing = true;
                            //get the array string for the request
                            let arrayStr = clickArray.toString();
                            // prevent defaults 
                            event.preventDefault();
                            // send ajax POST request through http
                            $.ajax({
                                type: 'POST',
                                cache: false,
                                async: true,
                                url: 'http://localhost:8080/crop?cropArray=' + arrayStr + '&currentImage=' +'<%= image %>',
                                success: function(response) { 
                                    // on success load the new html data into the page    
                                    $("html").html(response);
                                    // set the loader to invisible
                                    loadInvisible();
                                    // reset clickarray
                                    clickArray = [];
                                    // reset flag
                                    cropFlag = false;
                                },
                                error: function(xhr, status, err) {
                                    // on error log the error
                                    console.log(xhr.responseText);
                                    alert('Crop Failed');
                                    loadInvisible();
                                }
                            });
                            
                        }
                    }  
                }); // end image click
 */
                // set values for calculating outline box size 
                var mouseX,
                    mouseY,
                    startX,
                    startY;
                    
                    
                // ready the cropArray before pasing the points ion the required order
                // must be done this way because we cannot pass negative width and height values
                function prepareCrop(clickArray){
                    var startX = clickArray[0],
                        startY = clickArray[1],
                        endX = clickArray[2],
                        endY = clickArray[3];

                    if(startX > endX && startY > endY){
                        clickArray[0] = endX;
                        clickArray[1] = endY;
                        clickArray[2] = startX;
                        clickArray[3] = startY;
                    }
                    else if(startX > endX || startY > endY){
                        if(startX > endX){
                            clickArray[0] = startX - (startX - endX);
                            clickArray[2] = endX + (startX - endX);
                        }
                        else{
                            
                            clickArray[1] = startY - (startY - endY);
                            clickArray[3] = endY + (startY - endY);
                        }
                    }

                    return clickArray;
                }

               /*  // capture mouse position on image mouse over
                $('#crop').mousemove(function(event){
                    event.preventDefault();

                    // set event variables
                    var t = event.target;
                    var x = event.clientX;
                    var y = event.clientY;
                
                    // get proper svg as target
                    var target = (t == svg ? svg : t.parentNode);
                    
                    // get new svg relative point
                    var svgP = svgPoint(target, x, y);
                    // convert to int
                    mouseX = parseInt(svgP.x),
                    mouseY = parseInt(svgP.y);

                    console.log( "mouse over image: " + mouseX +': ' + mouseY);
                    
                    // only adjust the box if currently croppping
                    if(!doneResizing && clickArray.length > 1){
                        
                        adjustBox();
                    }
                }); */

                var line,
                    lineArr = [],
                    userLineColor;
                 
                $('#svgWrapper').on("click", function(event){
                    
                    // set event variables
                    var t = event.target,
                        x = event.clientX,
                        y = event.clientY;

                    // TODO: figure our how to buffer the Y portion
                    var bufferY = parseInt(Number(<%=h%>) * .09);
                    
                    // get proper svg as target
                    var target = (t == svg ? svg : t.parentNode);
                    
                    // get new svg relative point
                    var svgP = svgPoint(target, x, y);
                    // convert to int
                    mouseX = parseInt(svgP.x),
                    mouseY = parseInt(svgP.y);
                    
                    // if the draw flag is true and length of clicks is 0
                    if(drawFlag && clickArray.length === 0 && document.elementFromPoint(event.clientX, event.clientY) !== svg){
                        // create the new  line dynamically and add it to the array so we can remove it later if needed
                        line = document.createElementNS("http://www.w3.org/2000/svg","line");
                        line.setAttribute("x1",mouseX);
                        line.setAttribute("y1",mouseY);
                        line.setAttribute("x2",mouseX);
                        line.setAttribute("y2",mouseY);
                        line.style.visibility = "visible";
                        if(userLineColor){
                            line.style.stroke = userLineColor;
                        }else{
                            line.style.stroke = "white";
                        }
                        
                        line.style.strokeWidth = 4;
                        svg.appendChild(line);

                        lineArr.push(line);
                        captureClick(mouseX,mouseY);
                    }
                    else if(drawFlag && clickArray.length > 1  && document.elementFromPoint(event.clientX, event.clientY) !== svg){
                        // if the line is being drawn and the seconf click happens set the final location
                        line.setAttribute("x2",mouseX);
                        line.setAttribute("y2",mouseY);
            
                        clickArray = [];
                        drawFlag = false;
                        // reset the button color and allow for click detection again
                        document.getElementById("pencilIconFlag").className = "btn btn-lg button";

                        if(lineArr.length > 0){
                            document.getElementById("undoLine").style.visibility = "visible";
                        }

                        bg.className.baseVal = "";

                        
                        let svgElements = svg.childNodes;
                        // parse the whole svg and set the pointerevents to accept clicks again
                        for(index in svgElements){
                            if(svgElements[index].classList && svgElements[index].classList.contains("draggable")){
                                svgElements[index].style.pointerEvents = "visible";
                                if(svgElements[index].childNodes){
                                    for(index2 in svgElements[index].childNodes){
                                        if(svgElements[index].childNodes[index2].classList && svgElements[index].childNodes[index2].classList.contains("resize")){
                                            svgElements[index].childNodes[index2].style.pointerEvents = "painted";
                                        }
                                    }
                                }
                            }
                        }
                    }
                   
                 /*   COMMENTING OUT FOR NOW
                     if(cropFlag){
                        // clicking close to the 0,0
                        if(mouseX < 0 && mouseY < bufferY){
                            captureClick(0,0);
                        }
                        // if the click is close to max corner(bottom right)
                        else if(mouseY > Number(<%=h%>) - bufferY && mouseX > Number(<%=w%>)){
                            captureClick(<%=w%>,<%=h%>);
                        }
                        // if the click is close to the top right 
                        else if(mouseX > Number(<%=w%>) && mouseY < bufferY){
                            captureClick(<%=w%>,0);
                        }
                        // if the click is close to bottom left corner
                        else if(mouseX < 0 && mouseY > Number(<%=h%>) - bufferY){
                            captureClick(0,<%=h%>);
                        }
                        // for left side
                        else if(mouseX < 0 && mouseY < Number(<%=h%>) - bufferY){
                            captureClick(0,mouseY);
                        }
                        // for right side
                        else if(mouseX > Number(<%=w%>) && mouseY < Number(<%=h%>) - bufferY && mouseY > bufferY){
                            captureClick(<%=w%>,mouseY);
                        }

                        if(!doneResizing){
                                console.log(clickArray);
                            outlineBox.style.visibility = 'visible';
                            svg.appendChild(outlineBox);
                            outlineBox.setAttribute('x',clickArray[0]);
                            outlineBox.setAttribute('y',clickArray[1]);
                        }

                        if(clickArray.length === 4){
                            // and if the points arent stacked
                            if((clickArray[0] === clickArray[2] && clickArray[0] !== 0) || clickArray[1] === clickArray[3]){
                                clickArray = [];
                                alert('Cannot be cropped in this manner');
                                cropFlag = false;
                                document.getElementById('cropFlag').innerHTML = "Crop Image";
                            
                            }
                            else{
                                prepareCrop(clickArray);
                                // activate loader gif 
                                loaderActivate();
                                // set done resizeing flag
                                doneResizing = true;
                                //get the array string for the request
                                let arrayStr = clickArray.toString();
                                // prevent defaults 
                                event.preventDefault();
                                // send ajax POST request through http
                                $.ajax({
                                    type: 'POST',
                                    cache: false,
                                    async: true,
                                    url: 'http://localhost:8080/crop?cropArray=' + arrayStr + '&currentImage=' +'<%= image %>',
                                    success: function(response) { 
                                        // on success load the new html data into the page    
                                        $("html").html(response);
                                        // set the loader to invisible
                                        loadInvisible();
                                        // reset clickarray
                                        clickArray = [];
                                        // reset flag
                                        cropFlag = false;
                                    },
                                    error: function(xhr, status, err) {
                                        // on error log the error
                                        console.log(xhr.responseText);
                                        alert('Crop Failed');
                                        loadInvisible();
                                    }
                                });
                            }
                        } 
                        
                        
                    }
                     */
                });


                // used to update the line while still drawing
                function drawLine(lineElement,x2,y2){
                    lineElement.setAttribute("x2", x2);
                    lineElement.setAttribute("y2",y2);
                }


                 $('#svgWrapper').mousemove(function(event){
                    
                    // set event variables
                    var t = event.target;
                    var x = event.clientX;
                    var y = event.clientY;
                    // TODO: figure our how to buffer the Y portion
                    var bufferY = 50;
                    // get proper svg as target
                    var target = (t == svg ? svg : t.parentNode);
                    
                    
                    // get new svg relative point
                    var svgP = svgPoint(target, x, y);
                    // convert to int
                    mouseX = parseInt(svgP.x),
                    mouseY = parseInt(svgP.y);

                    //console.log('MOUSE MOVING OVER SVG BOX: ' + mouseX + ': ' + mouseY);
                    if( drawFlag && clickArray.length >1  && document.elementFromPoint(event.clientX, event.clientY) !== svg){
                        drawLine(line, mouseX, mouseY);
                    }
                        
                        
/*
                    if(cropFlag && !doneResizing){


                        // clicking close to the 0,0
                        if(mouseX < 0 && mouseY < bufferY){
                            mouseX = 0;
                            mouseY = 0;
                        }
                        // if the click is close to max corner(bottom right)
                        else if(mouseY > Number(<%=h%>) - bufferY && mouseX > Number(<%=w%>)){
                            mouseX = <%=w%>;
                            mouseY = <%=h%>;
                        }
                        // if the click is close to the top right 
                        else if(mouseX > Number(<%=w%>) && mouseY < bufferY){
                            mouseX = <%=w%>;
                            mouseY = 0;
                        }
                        // if the click is close to bottom left corner
                        else if(mouseX < 0 && mouseY > Number(<%=h%>) - bufferY){
                            mouseX = 0;
                            mouseY = <%=h%>;
                        }
                        // for left side
                        else if(mouseX < 0 && mouseY < Number(<%=h%>) - bufferY){
                            mouseX = 0;
                            
                        }
                        // for right side
                        else if(mouseX > Number(<%=w%>) && mouseY < Number(<%=h%>) - bufferY && mouseY > bufferY){
                            mouseX = <%=w%>;
                        }
                        adjustBox();
                    }*/
                }); 
            
                // function to change the outline box dimensions to the calulated size
                function adjustBox(){

                    // get start points of the crop
                    startX = clickArray[0];
                    startY = clickArray[1];

                    // convert number and do the math
                    let w = Number(mouseX) - startX;
                    let h = Number(mouseY) - startY;
                    
                    // reset the outline box if the values are not NaN
                    if(w !== NaN && h !== NaN){
                        if(w < 0 && h < 0){
                            h = Math.abs(h);
                            w = Math.abs(w);
                            

                            outlineBox.setAttribute('x' , startX  - w);
                            outlineBox.setAttribute('y' , startY - h);
                            outlineBox.setAttribute('width' , w);
                            outlineBox.setAttribute('height' , h);
                        }else if(w < 0 || h < 0){
                            if(w<0){
                                w = Math.abs(w);

                                outlineBox.setAttribute('x' , startX  - w);
                                outlineBox.setAttribute('y' , startY);
                                
                            }else{
                                h = Math.abs(h);
                                outlineBox.setAttribute('x' , startX);
                                outlineBox.setAttribute('y' , startY - h);
                            }
                            outlineBox.setAttribute('width' , w);
                            outlineBox.setAttribute('height' , h);
                        }else{
                            outlineBox.setAttribute('width' , w);
                            outlineBox.setAttribute('height' , h);
                        }
                        
                    }
                } 

                // variables for keeping track of the outline boxes
                var highlightBoxArray = [],
                    userBoxColor;

                // when the outline box is clicked
                $("#outlineBtn").on("mousedown",function(){
                    // generate the new scalable draggables group dynamically 
                    var g = document.createElementNS("http://www.w3.org/2000/svg","g");

                    g.setAttribute("class","draggable confine outline");
                    g.setAttribute("transform-origin","50%; 50%;");
                    g.setAttribute("transform","translate(0,0) rotate(0) scale(.5)");
                    g.setAttribute("stroke-width","10");
                    g.style.border = 0;
                    g.style.padding = 0;
                    g.style.pointerEvents = "visible";

                    g.innerHTML = attensionBoxObjectString;
                    
                    // set the color if needed
                    if(userBoxColor){
                        g.style.stroke = userBoxColor;
                        g.style.fill = "none";
                    }else{
                        g.style.fill = "none";
                        g.style.stroke = "white";
                    }
                    // append the group and reset the draggable functions
                    svg.appendChild(g);
                    // push the object into the array for undoing
                    highlightBoxArray.push(g);
                    makeDraggable(svg);


                    if(highlightBoxArray.length > 0){
                        document.getElementById("undoBox").style.visibility = "visible";
                    }

                });

                // array for removing text
                var textBoxArray = [];

                // when the text box is clicked
                $("#textBtn").on("mousedown",function(){
                    // prompt for text box contents
                    var textboxVal = prompt("What Should It Say?","");
                    
                    if(textboxVal !== "" && textboxVal){
                        
                        let strlength = textboxVal.length; 
                        let numberOfSpaces = textboxVal.split(" ").length;
                        

                        
                        // Draw the scaleable and draggable group with the new text element dynamically
                        var text = document.createElementNS("http://www.w3.org/2000/svg","text");
                        
                        var g = document.createElementNS("http://www.w3.org/2000/svg", "g");


                        g.setAttribute("class","draggable confine textbox");
                        g.setAttribute("x",0);
                        g.setAttribute("y",0);
                        text.setAttribute("x",0);
                        text.setAttribute("y",15);
                        text.style.fontSize = "15";
                        g.setAttribute("height",0);
                        g.setAttribute("width",0);
                        g.setAttribute("transform","translate(50,50) rotate(0) scale("+ textSize*2 + ")");

                        var rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
                        rect.setAttribute("x",0);
                        rect.setAttribute("y",13);
                        rect.setAttribute("width", 5);
                        rect.setAttribute("height", 5);
                        rect.style.visibility = "hidden";
                        rect.setAttribute("class","resize bottom-left");


                        var rect2 = document.createElementNS("http://www.w3.org/2000/svg","rect");
                        rect2.setAttribute("x",0);
                        rect2.setAttribute("y",1);
                        rect2.setAttribute("width", 5);
                        rect2.setAttribute("height", 5);
                        rect2.style.visibility = "hidden";
                        rect2.setAttribute("class","resize top-left");

                        var rect3 = document.createElementNS("http://www.w3.org/2000/svg","rect");
                        rect3.setAttribute("x",10);
                        rect3.setAttribute("y",1);
                        rect3.setAttribute("width", 9);
                        rect3.setAttribute("height", 7);
                        rect3.style.visibility = "hidden";
                        rect3.setAttribute("class","resize top-right");
                        rect3.setAttribute("fill","blue");

                        var rect4 = document.createElementNS("http://www.w3.org/2000/svg","rect");
                        rect4.setAttribute("x",10);
                        rect4.setAttribute("y",13);
                        rect4.setAttribute("width", 7);
                        rect4.setAttribute("height", 7);
                        rect4.setAttribute("fill","blue");
                        rect4.style.visibility = "hidden";
                        rect4.setAttribute("class","resize bottom-right");
                        

                        
                        g.style.pointerEvents = "visible"
                        text.innerHTML = textboxVal;
                        // append the scaleing corners
                        g.appendChild(text);
                        g.appendChild(rect);
                        g.appendChild(rect2);
                        g.appendChild(rect3);
                        g.appendChild(rect4);

                        // set the user text color
                        if(userTextColor){
                            text.setAttribute("stroke",userTextColor);
                            text.setAttribute("fill",userTextColor);
                        }else{
                            text.setAttribute("stroke","white");
                            text.setAttribute("fill","white");
                        
                        }

                        // set the stroke of the text and append the elements
                        text.setAttribute("stroke-width","1");
                        svg.appendChild(g);
                        let bbox = g.getBBox();
                        
                        if(strlength > 1){
                            rect3.setAttribute("x",bbox.width - 1);
                            rect4.setAttribute("x",bbox.width - 1);
                        }
                        
                    

                        textBoxArray.push(g);
                        if(textBoxArray.length > 0){
                            document.getElementById("undoText").style.visibility = "visible";
                        }

                        makeDraggable(svg);
                    }
                });


                // everytime  the check boxes is changed switch the places of the fill and stroke
                $("#textColorPicker").on("change",function(){
                    userTextColor = document.getElementById("textColorPicker").value;

                });
        


                // undoes the last added text element
                $("#undoText").on("mousedown",function(){
                    
                    if(textBoxArray.length > 0){
                        textBoxArray.pop().remove();
                    }else{
                        alert("text has not been added");
                    }
                    if(textBoxArray.length === 0){
                        document.getElementById("undoText").style.visibility = "hidden";
                    }
                });
                // declare the drawing flag
                var drawFlag = false;


                // removes a line the user just drew by using Escape w/o resetting the button
                $(document).keyup(function(event){
                    // when escape is clicked with the drawFlag true
                    if(event.keyCode === 27 && drawFlag){
                        if(lineArr.length > 0 && clickArray.length > 1){
                            lineArr.pop().remove();
                            clickArray = [];
                        }
                    }
                });



                // when the mouse clicks the draw button
                $("#pencilIconFlag").on('mousedown',function(){
                    if(drawFlag){
                        drawFlag = false;
                        // reset the interface 
                        bg.className.baseVal = "";
                        document.getElementById("pencilIconFlag").className = "btn btn-lg button";
                        clickArray = [];
                        // remove half drawn lines
                        if(lineArr.length && clickArray > 1){
                            lineArr.pop().remove();
                        }
                        // get the children of the svg element
                        let svgElements = svg.childNodes;
                        
                        // for every child
                        for(index in svgElements){
                            // if the group is draggable
                            if(svgElements[index].classList && svgElements[index].classList.contains("draggable")){
                                // reset the pointer events
                                svgElements[index].style.pointerEvents = "visible";
                                // add if that element has child nodes
                                if(svgElements[index].childNodes){
                                    // do the same with its children
                                    for(index2 in svgElements[index].childNodes){
                                        if(svgElements[index].childNodes[index2].classList && svgElements[index].childNodes[index2].classList.contains("resize")){
                                            svgElements[index].childNodes[index2].style.pointerEvents = "painted";
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else{
                        bg.className.baseVal = "draw";
                        drawFlag = true;
                        document.getElementById("pencilIconFlag").className = "btn btn-light btn-lg button";


                        let svgElements = svg.childNodes;

                        // loop through all children and children of the children and set the pointer 
                        // events to none so the draw function does not get interfiered with
                        for(index in svgElements){
                            if(svgElements[index].classList && svgElements[index].classList.contains("draggable")){
                                svgElements[index].style.pointerEvents = "none";
                                if(svgElements[index].childNodes){
                                    for(index2 in svgElements[index].childNodes){
                                        if(svgElements[index].childNodes[index2].classList && svgElements[index].childNodes[index2].classList.contains("resize")){
                                            svgElements[index].childNodes[index2].style.pointerEvents = "none";
                                        }
                                    }
                                }
                            }
                        }

                        
                    }
                });

                // removes any outline boxes if they exist
                $("#undoBox").on("mousedown",function(){
                    if(highlightBoxArray.length > 0){
                        highlightBoxArray.pop().remove();
                    }else{
                        alert("There are no boxes placed yet");
                    }
                    if(highlightBoxArray.length === 0){
                       document.getElementById("undoBox").style.visibility = "hidden";
                    }
                });

                // removes any lines if they exists
                $("#undoLine").on("mousedown",function(){
                    if(lineArr.length > 0 && clickArray.length > 1){
                        lineArr.pop().remove();
                        svg.className.baseVal = "image-image float-center";
                        document.getElementById("pencilIconFlag").className = "btn btn-lg button";
                        drawFlag = false;
                        clickArray = [];
                    }
                    else if(lineArr.length > 0){
                        lineArr.pop().remove();
                    }
                    else{
                        alert("No lines drawn");
                    }


                    if(lineArr.length === 0){
                        document.getElementById("undoLine").style.visibility = "hidden";
                    }

                });

                // simply sets the color when the value is changed
                $("#colorPickerLine").change(function(){
                    userLineColor = document.getElementById("colorPickerLine").value;
                });
                $("#colorPickerBox").change(function(){
                    userBoxColor = document.getElementById("colorPickerBox").value;
                });




                // when north button is clicked
                $('#northIconFlag').on('mousedown',function(){
                    if(!document.getElementById("northIconFlag").classList.contains("disabled")){
                        // change north flag
                        northFlag = !northFlag;
                        
                        // if north flag is placed currently remove it
                        if(northIconPlaced){
                            northIconPlaced = !northIconPlaced;
                            northImage.remove();
                            northImage.style.visibility = 'hidden';
                            document.getElementById('northIconFlag').setAttribute('class',"btn btn-lg button");
                            document.getElementById("northCheckbox").style.visibility = "hidden";
                            document.getElementById("northCheckboxLabel").style.visibility = "hidden";
                            
                            
                            northFlag = !northFlag;
                        }
                        
                        // otherwise set the other flags to false and adjust their html
                        if(northFlag){
                            if(!sunIconPlaced){
                                sunFlag = false;
                                document.getElementById('sunIconFlag').innerHTML = "Add Sun Icon";
                            }

                            if(!eyeIconPlaced){
                                eyeFlag = false;
                                document.getElementById('eyeFlag').innerHTML = "Add Observer Icon";
                            }

                            /* cropFlag = false;
                            document.getElementById('cropFlag').innerHTML = "Crop Image"; */
                            outlineBox.remove();
                            outlineBox.style.visibility = 'hidden';
                            
                            svg.appendChild(northImage);
                            northImage.style.visibility = 'visible';
                            setIconAngle(northImage, northDegree);
                            makeDraggable(svg);
                            northIconPlaced = !northIconPlaced;
                            northFlag = false;
                            document.getElementById('northIconFlag').setAttribute('class',"btn btn-danger btn-lg button");
                            document.getElementById("northCheckbox").style.visibility = "visible";
                            document.getElementById("northCheckboxLabel").style.visibility = "visible";
                        }
                        
                        clickArray = [];
                    }
                    
                }); 


                // use same logic for other button
                $('#eyeFlag').click(function(){
                    if(!document.getElementById("eyeFlag").classList.contains("disabled")){
                        eyeFlag = !eyeFlag;

                        if(eyeIconPlaced){
                            eyeIconPlaced = !eyeIconPlaced;
                            eyeImage.remove();
                            eyeImage.style.visibility = 'hidden';
                            eyeFlag = !eyeFlag;
                            document.getElementById('eyeFlag').setAttribute('class',"btn btn-lg button");
                            document.getElementById("eyeCheckbox").style.visibility = "hidden";
                            document.getElementById("eyeCheckboxLabel").style.visibility = "hidden";
                           
                        }

                        if(eyeFlag){
                            
                            cropFlag = false;
                        /*  document.getElementById('cropFlag').innerHTML = "Crop Image"; */
                            outlineBox.remove();
                            outlineBox.style.visibility = 'hidden';
                            
                            svg.appendChild(eyeImage);
                            setIconAngle(eyeArrow, observerDegree);
                            eyeImage.style.visibility = 'visible'
                            document.getElementById('eyeFlag').setAttribute('class',"btn btn-danger btn-lg button");
                            document.getElementById("eyeCheckbox").style.visibility = "visible";
                            document.getElementById("eyeCheckboxLabel").style.visibility = "visible";
                            eyeFlag = false;
                            eyeIconPlaced = true;
                        }
                    } 
                });

                // use same logic for other button
                $('#sunIconFlag').click(function(){
                    
                    if(!document.getElementById("sunIconFlag").classList.contains("disabled")){
                        sunFlag = !sunFlag;

                        if(sunIconPlaced){
                            sunIconPlaced = !sunIconPlaced;
                            sunImage.style.visibility = 'hidden';
                            sunImage.remove();
                            document.getElementById('sunIconFlag').setAttribute('class',"btn btn-lg button");
                            sunFlag = false;
                            document.getElementById("sunCheckbox").style.visibility = "hidden";
                            document.getElementById("sunCheckboxLabel").style.visibility = "hidden";

                        }
                        
                        if(sunFlag){
                            
                            cropFlag = false;
                            outlineBox.style.visibility = 'hidden';
                            
                        /*  document.getElementById('cropFlag').innerHTML = "Crop Image"; */
                            sunImage.style.visibility = 'visible';
                            svg.appendChild(sunImage);
                            sunFlag = false;
                            sunIconPlaced = true;
                            document.getElementById('sunIconFlag').setAttribute('class',"btn btn-danger btn-lg button");
                            document.getElementById("sunCheckbox").style.visibility = "visible";
                            document.getElementById("sunCheckboxLabel").style.visibility = "visible";
                            
                            setIconAngle(sunImage, sunDegree);
                            makeDraggable(svg);  
                        }
                        
                        clickArray = [];
                    }
                    
                });



                $("#hideBtn").on("mousedown", function(){
                    document.getElementById("help-box").style.visibility = "hidden";
                });

                $("#helpBtn").on("mousedown", function(){
                    document.getElementById("help-box").style.visibility = "visible";
                });



/* 
                // use same logic for other button
                $("#cropFlag").click(function(){
                    cropFlag = !cropFlag;

                    if(cropFlag){
                        if(!northIconPlaced){
                            northFlag = false
                            document.getElementById('northIconFlag').innerHTML = "Add North Arrow";
                        }
                        if(!sunIconPlaced){
                            sunFlag = false;
                            document.getElementById('sunIconFlag').innerHTML = "Add Sun Icon";
                        }
                        if(eyeFlag && !eyeIconPlaced){
                            eyeFlag = false;
                            document.getElementById('eyeFlag').innerHTML = "Add Observer Icon";
                        }

                        document.getElementById('cropFlag').innerHTML = "Cancel?";
                        
                    }else{
                        clickArray = [];
                        document.getElementById('cropFlag').innerHTML = "Crop Image";
                        outlineBox.style.visibility = 'hidden';
                    }
                    
                }); */




/* 
                // button to undo the cropped image
                $("#backBtn").on('click',function(event){
                    event.preventDefault();

                    var currentImg = '<%= image %>';

                    console.log(currentImg);

                    // if the image has been cropped then get the previous image
                    if(currentImg.indexOf('_crop.png') > -1){
                        // ajax request for the data sending the current image link
                        $.ajax({
                            type: 'GET',
                            
                            cache: false,
                            url: 'http://localhost:8080/crop?currentImage=' +'<%= image %>',
                            success: function(response) {
                                $("html").html(response);
                            
                                
                            },
                            error: function(xhr, status, err) {
                                console.log(xhr.responseText);
                                loadInvisible();
                                
                            }
                        });
                    }else{
                        // if the current image is the base image then alert the user
                        loadInvisible();
                        alert('Base Image:\nCannot Be Undone');
                    }

                    
                }); */
            
            }); // end doc.ready
            
            // function to push the x,y coordinates into the clickArray
            function captureClick(x,y){
                clickArray.push(x);
                clickArray.push(y);
            }

            
            // Export Section

            // works for any file type as long as the image is not massive
            function triggerDownload (imgURI,filename) {
                // create a click event
                var event = new MouseEvent('click', {
                    view: window,
                    bubbles: false,
                    cancelable: true
                });
                // create an anchor for the download and the file using the image URI data
                var a = document.createElement('a');
                a.setAttribute('download', filename);
                a.setAttribute('href', imgURI);
                a.setAttribute('target', '_blank');

                // activate the event
                a.dispatchEvent(event);
            }

            

            $('#exportBtn').on("mousedown",function(){
                loader.style.visibility = "visible";
                document.getElementById("loadingText").innerHTML = "Compressing Image";
                
            });


            // when the export is clicked
            exportBtn.addEventListener('click', function () {

                // get the canvas information
                canvas = document.getElementById('canvas');
                var ctx = canvas.getContext('2d',{alpha:false});
                // encode the svg
                var data = (new XMLSerializer()).serializeToString(svg);

                // get the window URL element on any browser
                var DOMURL = window.URL || window.webkitURL || window;

                var svgBlob = new Blob([data], {type: 'image/svg+xml;charset=utf-8'});
                // creates an object url for the download
                var url = DOMURL.createObjectURL(svgBlob);

                // creates a new blank image
                var img = new Image();

               /*  // creates a blob from the encoded svg and sets the type of the blob to svg
                var svgBlob = new Blob([data], {type: 'image/svg+xml;charset=utf-8'});
                // creates an object url for the download
                var url = DOMURL.createObjectURL(svgBlob); */
        

                // when the image is done being created and its loaded
                img.onload = function(){
                    document.getElementById("loadingText").innerHTML = "Writing File";
                    // draw the svg image onto the canvas
                    ctx.drawImage(img,0,0);
                    
                    console.log("done writing to canvas");
                    // if the filename is a false value
                    if(!filename){
                        
                        // read in a filename with prompt
                        var filename = prompt("Save File as png svg or jpeg","");
                    }

                    // if the filename is one of the accepted filenames and it isnt null              
                    if( filename !== null && /^.*\.(png|PNG|JPEG|jpeg|JPG|jpg|SVG|svg)$/gm.test(filename)){
                        var fileExt = filename.split(".")[filename.split(".").length - 1];

                        // if the fileExt is NOT svg
                        if(fileExt !== 'svg'){
                            try{
                                if(fileExt === 'jpg'){
                                    // export an image of jpeg becuse jpg defaults to png
                                    url = canvas
                                    .toDataURL('image/jpeg', 1.0)
                                    .replace('image/jpeg', 'image/octet-stream');
                                }
                                else{
                                    // export an image of the extension type given
                                    url = canvas
                                    .toDataURL('image/'+fileExt, 1.0)
                                    .replace('image/'+fileExt, 'image/octet-stream');
                                }
                                
                                // start the download
                                triggerDownload(url,filename);            
                            }catch(err){
                                alert('Image is too large to save from browser');
                            }
                        }else{
                            // fileExt === 'svg'
                            try{
                                // trigger the download with the svg url instead of converting to image
                                triggerDownload(url,filename); 

                            }catch(err){
                                alert('Image is too large to save from browser');
                            }
                        }
                    }
                    // must enter an accepted fileExt
                    else if(filename !== null){
                        // make the user try again
                       exportBtn.click();
                    }
                    loader.style.visibility = "hidden";
                    document.getElementById("loadingText").innerHTML = "Loading";
                    // revoke the url
                    DOMURL.revokeObjectURL(url);

                    
                    // Note:
                    //     if the user hits cancel the filename will be null, we ignore this case
                };
                
                img.src = url;


            });
        </script>

        <!-- Legend Section (depricated right now) -->
        <br/>
        <div class="position-relative text-center" style="margin-left:auto; margin-right:auto; display: none;">
            <h2 style="padding-top:1%;padding-bottom:1%; margin-bottom: 0%;">Image Legend</h2>
            <table class="float-center text-center" style="margin-left:auto; margin-right:auto; margin-top: 0px;">
                <tr>
                    <td>
                        <svg id="legend-image" width="450" height="200">
                            <rect width="100%" height="100%" rx="10" ry="10" style="fill:rgb(233, 236, 239);">
                            </rect>
                            <foreignObject x="10" y="10" width="100%" height="100%">
                                <table class="float-center" id="legend-table">
                                    <tr id="north">
                                        <th>North:</th>
                                        <th><img id="northImg" src="images/north.png" width="25" preserveAspectratio="xMaxYMid meet" height="25"><img/></th>
                                        <th id="northDeg">0 degrees</th>
                                    </tr>
                                    <tr id="sun-az">
                                        <th>Sun Azimuthal Direction:</th>
                                        <th><img id="sunImg" src="images/sun_symbol.png" width="25" height="25"></img></th>
                                        <th id="sunDeg">0 degrees</th>
                                    </tr>
                                    <tr id="obs-az">
                                        <th>Observer Azimuthal Direction:</th>
                                        <th><img id="observerImg" src="images/eye_symbol.png" width="25" height="25"></img></th>
                                        <th id="obsDeg">0 degrees</th>
                                    </tr>
                                    <tr id="image-scalebar" style="overflow:hidden;">
                                        <th>Scalebar:</th>
                                        <th><img src="images/arrow.png" width="25" height="25"></img></th>
                                        <th id="scaleDeg">0 degrees</th>
                                    </tr>   
                                </table>
                            </foreignObject>
                            <line id="observerArrow" x1="0" y1="0" x2="50" y2="0" style="stroke:rgb(255,0,0);stroke-width:2; display:none;"/>
                            <line id="sunArrow" x1="0" y1="0" x2="50" y2="0" style="stroke:rgb(255,0,0);stroke-width:2; display:none;"/>
                        </svg>
                    </td>
                    <td valign="top">
                        <div class="float-center" style="align-content: center; width: 300px; height: auto; margin: auto;">
                            <div id="hide-legend" class="float-center" style="text-align: left;">
                                <table style="text-align:left;">
                                    <tr><h4>Hide Legend Elements</h4></tr>
                                    <tr><input type="checkbox" id="north-radio" name="leg" checked>North Arrow</input><br/></tr>
                                    <tr><input type="checkbox" id="sun-radio" name="leg" checked>Sun Azimuthal Direction</input><br/></tr>
                                    <tr><input type="checkbox" id="obs-radio" name="leg" checked>Observer Azimuthal Direction</input><br/></tr>
                                    <tr><input type="checkbox" id="scalebar-radio" name="leg" checked>Scalebar</input><br/></tr>
                                </table>
                            </div>
                        </div>
                    </td>
                </tr>
            </table>
        </div>
        
                                                                     
        <script type="text/javascript">
            function hideNorth(){
                document.getElementById("north").style.display = "none";
                
            }
            function showNorth(){
                document.getElementById("north").style.display = "table-row";
                
            }
            function hideSun(){
                document.getElementById("sun-az").style.display = "none";
            }
            function showSun(){
                document.getElementById("sun-az").style.display = "table-row";
            }
            function hideObs(){
                document.getElementById("obs-az").style.display = "none";
            }
            function showObs(){
                document.getElementById("obs-az").style.display = "table-row";
            }
            function hideScale(){
                document.getElementById("image-scalebar").style.display = "none";
               
            }
            function showScale(){
                document.getElementById("image-scalebar").style.display = "table-row";
                
            }

            // function to hide the elements in the legend area
            function showHide(){
                var northRadio = document.getElementById("north-radio").checked;
                var sunRadio = document.getElementById("sun-radio").checked;
                var obsRadio = document.getElementById("obs-radio").checked;
                var scalebarRadio = document.getElementById("scalebar-radio").checked;
                if(!northRadio){
                    hideNorth();
                }else{
                    showNorth();
                }
                if(!sunRadio){
                    hideSun();
                }else{
                    showSun();
                }
                if(!obsRadio){
                    hideObs();
                }else{
                    showObs();
                }
                if(!scalebarRadio){
                    hideScale();
                }else{
                    showScale();
                }
            }
            setInterval(showHide, 1000);
        </script>

        <script type="text/javascript">
            // degree variables
            var northDegree,
                sunDegree,
                observerDegree;

            // create an enumerated object for setting the scaling boxes
            var placeEnum = new Object({
                        "top-left":1,
                        "top-right":2,
                        "bottom-right":3,
                        "bottom-left":4
                        });
        
            // prototype for any object
            // when given a value of a JSON object it retrieve the associated key
            Object.prototype.getNameWithVal = function(val){
                let tmpArr = Object.keys(this);
                for(key in tmpArr){
                    if( this[tmpArr[key]] === val){
                        return tmpArr[key];
                    }
                }
            }

            // boolean to tell if the image is map projected
            var isMapProjected = <%=isMapProjected %>;
 
            // Gets Important Metadata from the "metadata-text" div
            function getMetadata(){
                // get value string from hidden DOM element
                var metadata = document.getElementById("metadata-text").innerHTML;

                // parse back into JSON
                var metadataString = JSON.parse(metadata);
                
                // Important Metadata Values adding degree offset for isis
                northDegree = parseFloat(metadataString['NorthAzimuth']) + 90;
                sunDegree = parseFloat(metadataString['SubSolarAzimuth'])+ 90;
                observerDegree = parseFloat(metadataString['SubSpacecraftGroundAzimuth']) + 90;
                
                if(isNaN(northDegree)){
                    // check if it is map projected, if yes set north to 0 else
                    if(isMapProjected){
                        let rotateOffset = parseFloat("<%=rotationOffset %>");
                        if(!isNaN(rotateOffset)){
                            northDegree = 0 + rotateOffset;
                        }
                    }else{
                        // disable the button if the degree was not found
                        document.getElementById("north-radio").checked = false;
                        document.getElementById('northIconFlag').setAttribute('class',"btn btn-secondary btn-lg button disabled");
                    }
                }else{
                    setLegendAngle("northImg", "northDeg", northDegree);
                }

                if(isNaN(sunDegree)){
                    // disable the button if the degree was not found
                    document.getElementById("sun-radio").checked = false;
                    document.getElementById('sunIconFlag').setAttribute('class',"btn btn-secondary btn-lg button disabled");
                }

                if(isNaN(observerDegree)){
                    // disable the button if the degree was not found
                    document.getElementById("obs-radio").checked = false;
                    document.getElementById('eyeFlag').setAttribute('class',"btn btn-secondary btn-lg button disabled");
                }


                // if the degree value is over 360 just subtract 360 because the math is easier
                if(northDegree>360){northDegree-=360;}
                if(sunDegree>360){sunDegree-=360;}
                if(observerDegree>360){observerDegree-=360;}
                // set the scale bar corners to the correct orientation
                setScaleboxCorners(northDegree, sunDegree);
            }

            // set the arrow directions and recieve the data
            getMetadata();
            

            // this function figures out where to draw the scalebar corners to better fit the new icon orientation
            function setScaleboxCorners(northDegree, sunDegree){
                // as long as northDegree is not NaN and not 0 we will need to adjust the boxes
                if(!isNaN(northDegree) &&  northDegree!== 0){
                    // get the child list
                    let childList = northImage.childNodes;
                    let offset90 = Math.round(northDegree / 90);
                    let offset45 = northDegree / 45;

                    /* 
                    1. each corner was given a numeric value starting from top-left and going clockwise around the image
                    2. I caculate how many times 90 goes into the degree and i shift the boxes by that amount
                    3. by adding the ossfet to the box values it tells us where that box should move to. 
                    */
                    for(index in childList){
                        if(childList[index].classList && childList[index].classList.contains("resize") && offset90 >= 1 && offset90 <= 4){
                            
                            if(childList[index].classList.contains("top-left")){
                                let newClass = placeEnum["top-left"] + offset90;
                                if(newClass > 4){newClass -= 4}
                                

                                childList[index].setAttribute("class","resize " + placeEnum.getNameWithVal(newClass));
                            }
                            else if(childList[index].classList.contains("top-right")){
                                let newClass = placeEnum["top-right"] + offset90;
                                if(newClass > 4){newClass -= 4}
                                

                                childList[index].setAttribute("class","resize " + placeEnum.getNameWithVal(newClass));
                            }
                            else if(childList[index].classList.contains("bottom-right")){
                                let newClass = placeEnum["bottom-right"] + offset90;
                                if(newClass > 4){newClass -= 4}
                                

                                childList[index].setAttribute("class","resize " + placeEnum.getNameWithVal(newClass));
                            }
                            else if(childList[index].classList.contains("bottom-left")){
                                let newClass = placeEnum["bottom-left"] + offset90;
                                if(newClass > 4){newClass -= 4}
                                

                                childList[index].setAttribute("class","resize " + placeEnum.getNameWithVal(newClass));
                            }
                        }
                        
                    }
                }
                // same is done for each icon that rotates
                if(!isNaN(sunDegree)){
                    let childList = sunImage.childNodes;
                    let offset90 = Math.round(sunDegree / 90);
                    
                    for(index in childList){
                        if(childList[index].classList && childList[index].classList.contains("resize") && offset90 >= 1 && offset90 <= 3){
                            
                            if(childList[index].classList.contains("top-left")){
                                let newClass = placeEnum["top-left"] + offset90;
                                if(newClass > 4){newClass -= 4}
                                

                                childList[index].setAttribute("class","resize " + placeEnum.getNameWithVal(newClass));
                            }
                            else if(childList[index].classList.contains("top-right")){
                                let newClass = placeEnum["top-right"] + offset90;
                                if(newClass > 4){newClass -= 4}
                                

                                childList[index].setAttribute("class","resize " + placeEnum.getNameWithVal(newClass));
                            }
                            else if(childList[index].classList.contains("bottom-right")){
                                let newClass = placeEnum["bottom-right"] + offset90;
                                if(newClass > 4){newClass -= 4}
                                

                                childList[index].setAttribute("class","resize " + placeEnum.getNameWithVal(newClass));
                            }
                            else if(childList[index].classList.contains("bottom-left")){
                                let newClass = placeEnum["bottom-left"] + offset90;
                                if(newClass > 4){newClass -= 4}
                                

                                childList[index].setAttribute("class","resize " + placeEnum.getNameWithVal(newClass));
                            }
                        }
                    }
                }
            }



            

            // Set Legend North Angle Angle
            function setLegendAngle(img, degree, value){
                // get the image element and the element to display the angle degree
                let image = document.getElementById(String(img));
                let deg = document.getElementById(String(degree));
                // rotate the value using css transform
                let rotateVal = String("transform: rotate(" + String(value) + "deg);");
                // transform about the origin
                image.setAttribute("transform-origin", "50%; 50%;");
                // change the html angle display
                deg.innerHTML = String(value) + "degrees";

                // set the new style for the image
                image.setAttribute("style", rotateVal);
            }

            // set the transform rotate() string of the given icon
            function setIconAngle(icon, degree){
                if(!isNaN(degree)){
                    let transformVal = icon.getAttribute("transform");
                    let transformArray = transformVal.split(" ");

                    let offsetX = 0,
                        offsetY = 0;

                    // rotate the arrow around the center point of the eye
                    if(icon.id.indexOf('eye') > -1){
                        for(index in transformArray){
                            if(transformArray[index].indexOf("rotate") > -1){
                                var tmp = transformArray[index].split("rotate(")[1];
                                
                                tmp = tmp.replace(")"," ").trim();
                                tmp = degree;
                                transformArray[index] = "rotate("+ tmp +",75,55)";
                                
                                icon.setAttribute("transform", transformArray.join(" "));
                                return;
                            }
                        }
                    }
                    else{
                        for(index in transformArray){
                            
                            if(transformArray[index].indexOf("rotate") > -1){
                                var tmp = transformArray[index].split("rotate(")[1];
                                
                                tmp = tmp.replace(")"," ").trim();
                                tmp = degree;
                                transformArray[index] = "rotate("+ tmp +")";
                                
                                icon.setAttribute("transform", transformArray.join(" "));
                                return;
                            }

                        }
                    }
                    

                    // adds the new rotate() string in the exact same order as it appeared before to preserve the dragging function
                    let scaleStr = transformArray[transformArray.length -1];
                    let translateStr = transformArray[0];

                    let rotateStr = "rotate(" + String(degree) + ")";

                    transformArray.pop();
                    transformArray.push(rotateStr);
                    transformArray.push(scaleStr);
                    
                    icon.setAttribute("transform", transformArray.join(" "));
                    
                }
            }
        </script>
    </body>
</html>
